/** \file
 *  This C source file was generated by $ANTLR version 3.1.3 Mar 18, 2009 10:09:25
 *
 *     -  From the grammar source file : PBJ.g
 *     -                            On : 2010-06-28 11:25:28
 *     -                 for the lexer : PBJLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PBJLexer.h"
/* ----------------------------------------- */


/** String literals used by PBJLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x65, 0x78, 0x74, 0x65, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x74, 0x6F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x65, 0x6E, 0x75, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x66, 0x6C, 0x61, 0x67, 0x73, 0x38,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x66, 0x6C, 0x61, 0x67, 0x73, 0x31, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x66, 0x6C, 0x61, 0x67, 0x73, 0x33, 0x32,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x66, 0x6C, 0x61, 0x67, 0x73, 0x36, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x75, 0x69, 0x6E, 0x74, 0x38,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x69, 0x6E, 0x74, 0x38,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x73, 0x69, 0x6E, 0x74, 0x38,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x66, 0x69, 0x78, 0x65, 0x64, 0x38,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x38,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x75, 0x69, 0x6E, 0x74, 0x31, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x69, 0x6E, 0x74, 0x31, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x73, 0x69, 0x6E, 0x74, 0x31, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x66, 0x69, 0x78, 0x65, 0x64, 0x31, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x31, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x75, 0x69, 0x6E, 0x74, 0x33, 0x32,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x69, 0x6E, 0x74, 0x33, 0x32,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x73, 0x69, 0x6E, 0x74, 0x33, 0x32,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x33, 0x32,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x75, 0x69, 0x6E, 0x74, 0x36, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x69, 0x6E, 0x74, 0x36, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x73, 0x69, 0x6E, 0x74, 0x36, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x73, 0x66, 0x69, 0x78, 0x65, 0x64, 0x36, 0x34,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x66, 0x6C, 0x6F, 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x64, 0x6F, 0x75, 0x62, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x62, 0x6F, 0x6F, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x62, 0x79, 0x74, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x75, 0x75, 0x69, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x73, 0x68, 0x61, 0x32, 0x35, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x61, 0x6E, 0x67, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x73, 0x6F, 0x6C, 0x69, 0x64, 0x61, 0x6E, 0x67, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x74, 0x69, 0x6D, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x32, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x32, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x33, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x33, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x34, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x76, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x34, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x71, 0x75, 0x61, 0x74, 0x65, 0x72, 0x6E, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x70, 0x68, 0x65, 0x72, 0x65, 0x33, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x70, 0x68, 0x65, 0x72, 0x65, 0x33, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x62, 0x6F, 0x78, 0x33, 0x66, 0x33, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x62, 0x6F, 0x78, 0x33, 0x64, 0x33, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x74, 0x72, 0x75, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x66, 0x61, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_63[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_64[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pPBJLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pPBJLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pPBJLexer_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))						\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;											\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);		\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void	mPACKAGELITERAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mIMPORTLITERAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mDOT    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mMESSAGE    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mEXTEND    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mEXTENSIONS    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mRESERVE    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mTO    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mENUM    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFLAGS8    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFLAGS16    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFLAGS32    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFLAGS64    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mREQUIRED    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mPBJOPTIONAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mREPEATED    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mDEFAULT    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mEQUALS    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mBLOCK_OPEN    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mBLOCK_CLOSE    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mITEM_TERMINATOR    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mUINT8    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mINT8    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSINT8    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFIXED8    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSFIXED8    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mUINT16    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mINT16    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSINT16    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFIXED16    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSFIXED16    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mUINT32    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mINT32    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSINT32    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFIXED32    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSFIXED32    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mUINT64    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mINT64    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSINT64    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFIXED64    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSFIXED64    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFLOAT    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mDOUBLE    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mBOOL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mBYTES    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSTRING    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mUUID    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSHA256    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mANGLE    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSOLIDANGLE    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mTIME    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mDURATION    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mNORMAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mVECTOR2F    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mVECTOR2D    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mVECTOR3F    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mVECTOR3D    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mVECTOR4F    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mVECTOR4D    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mQUATERNION    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mBOUNDINGSPHERE3F    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mBOUNDINGSPHERE3D    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mBOUNDINGBOX3F3F    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mBOUNDINGBOX3D3F    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSQBRACKET_OPEN    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSQBRACKET_CLOSE    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSTRING_LITERAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mSTRING_GUTS    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mBOOL_LITERAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mHEX_LITERAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_LITERAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mOCTAL_LITERAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mHexDigit    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mFLOATING_POINT_LITERAL    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mExponent    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mEscapeSequence    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mOctalEscape    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mUnicodeEscape    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mIDENTIFIER    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mQUALIFIEDIDENTIFIER    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mCOMMENT    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mWS    (pPBJLexer ctx);
static ANTLR3_INLINE  void	mTokens    (pPBJLexer ctx);
static void	PBJLexerFree(pPBJLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
PBJLexerFree  (pPBJLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PBJ.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called PBJLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return 
 *     - Success pPBJLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pPBJLexer PBJLexerNew         
(pANTLR3_INPUT_STREAM instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return PBJLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called PBJLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return 
 *     - Success pPBJLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pPBJLexer PBJLexerNewSSD         
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pPBJLexer ctx; // Context structure we will build and return

    ctx = (pPBJLexer) ANTLR3_CALLOC(1, sizeof(PBJLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in PBJLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);
    
    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our PBJLexer interface
     */
    ctx->mPACKAGELITERAL	= mPACKAGELITERAL;
    ctx->mIMPORTLITERAL	= mIMPORTLITERAL;
    ctx->mDOT	= mDOT;
    ctx->mMESSAGE	= mMESSAGE;
    ctx->mEXTEND	= mEXTEND;
    ctx->mEXTENSIONS	= mEXTENSIONS;
    ctx->mRESERVE	= mRESERVE;
    ctx->mTO	= mTO;
    ctx->mENUM	= mENUM;
    ctx->mFLAGS8	= mFLAGS8;
    ctx->mFLAGS16	= mFLAGS16;
    ctx->mFLAGS32	= mFLAGS32;
    ctx->mFLAGS64	= mFLAGS64;
    ctx->mREQUIRED	= mREQUIRED;
    ctx->mPBJOPTIONAL	= mPBJOPTIONAL;
    ctx->mREPEATED	= mREPEATED;
    ctx->mDEFAULT	= mDEFAULT;
    ctx->mEQUALS	= mEQUALS;
    ctx->mBLOCK_OPEN	= mBLOCK_OPEN;
    ctx->mBLOCK_CLOSE	= mBLOCK_CLOSE;
    ctx->mITEM_TERMINATOR	= mITEM_TERMINATOR;
    ctx->mUINT8	= mUINT8;
    ctx->mINT8	= mINT8;
    ctx->mSINT8	= mSINT8;
    ctx->mFIXED8	= mFIXED8;
    ctx->mSFIXED8	= mSFIXED8;
    ctx->mUINT16	= mUINT16;
    ctx->mINT16	= mINT16;
    ctx->mSINT16	= mSINT16;
    ctx->mFIXED16	= mFIXED16;
    ctx->mSFIXED16	= mSFIXED16;
    ctx->mUINT32	= mUINT32;
    ctx->mINT32	= mINT32;
    ctx->mSINT32	= mSINT32;
    ctx->mFIXED32	= mFIXED32;
    ctx->mSFIXED32	= mSFIXED32;
    ctx->mUINT64	= mUINT64;
    ctx->mINT64	= mINT64;
    ctx->mSINT64	= mSINT64;
    ctx->mFIXED64	= mFIXED64;
    ctx->mSFIXED64	= mSFIXED64;
    ctx->mFLOAT	= mFLOAT;
    ctx->mDOUBLE	= mDOUBLE;
    ctx->mBOOL	= mBOOL;
    ctx->mBYTES	= mBYTES;
    ctx->mSTRING	= mSTRING;
    ctx->mUUID	= mUUID;
    ctx->mSHA256	= mSHA256;
    ctx->mANGLE	= mANGLE;
    ctx->mSOLIDANGLE	= mSOLIDANGLE;
    ctx->mTIME	= mTIME;
    ctx->mDURATION	= mDURATION;
    ctx->mNORMAL	= mNORMAL;
    ctx->mVECTOR2F	= mVECTOR2F;
    ctx->mVECTOR2D	= mVECTOR2D;
    ctx->mVECTOR3F	= mVECTOR3F;
    ctx->mVECTOR3D	= mVECTOR3D;
    ctx->mVECTOR4F	= mVECTOR4F;
    ctx->mVECTOR4D	= mVECTOR4D;
    ctx->mQUATERNION	= mQUATERNION;
    ctx->mBOUNDINGSPHERE3F	= mBOUNDINGSPHERE3F;
    ctx->mBOUNDINGSPHERE3D	= mBOUNDINGSPHERE3D;
    ctx->mBOUNDINGBOX3F3F	= mBOUNDINGBOX3F3F;
    ctx->mBOUNDINGBOX3D3F	= mBOUNDINGBOX3D3F;
    ctx->mSQBRACKET_OPEN	= mSQBRACKET_OPEN;
    ctx->mSQBRACKET_CLOSE	= mSQBRACKET_CLOSE;
    ctx->mSTRING_LITERAL	= mSTRING_LITERAL;
    ctx->mSTRING_GUTS	= mSTRING_GUTS;
    ctx->mBOOL_LITERAL	= mBOOL_LITERAL;
    ctx->mHEX_LITERAL	= mHEX_LITERAL;
    ctx->mDECIMAL_LITERAL	= mDECIMAL_LITERAL;
    ctx->mOCTAL_LITERAL	= mOCTAL_LITERAL;
    ctx->mHexDigit	= mHexDigit;
    ctx->mFLOATING_POINT_LITERAL	= mFLOATING_POINT_LITERAL;
    ctx->mExponent	= mExponent;
    ctx->mEscapeSequence	= mEscapeSequence;
    ctx->mOctalEscape	= mOctalEscape;
    ctx->mUnicodeEscape	= mUnicodeEscape;
    ctx->mIDENTIFIER	= mIDENTIFIER;
    ctx->mQUALIFIEDIDENTIFIER	= mQUALIFIEDIDENTIFIER;
    ctx->mCOMMENT	= mCOMMENT;
    ctx->mWS	= mWS;
    ctx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;
    
    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= PBJLexerFree;

    
    


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    592:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )? | '.' ( '0' .. '9' )+ ( Exponent )? | ( '0' .. '9' )+ Exponent );
 */
static const ANTLR3_INT32 dfa13_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa13_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa13_min[5] =
    {
	46, 46, -1, -1, -1
    };
static const ANTLR3_INT32 dfa13_max[5] =
    {
	57, 101, -1, -1, -1
    };
static const ANTLR3_INT32 dfa13_accept[5] =
    {
	-1, -1, 2, 1, 3
    };
static const ANTLR3_INT32 dfa13_special[5] =
    {	
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa13_T_empty	    NULL

static const ANTLR3_INT32 dfa13_T0[] =
    {
	3, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };static const ANTLR3_INT32 dfa13_T1[] =
    {
	2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa13_transitions[] =
{
    dfa13_T1, dfa13_T0, dfa13_T_empty, dfa13_T_empty, dfa13_T_empty	
};


/* Declare tracking structure for Cyclic DFA 13
 */
static
ANTLR3_CYCLIC_DFA cdfa13
    =	{
	    13,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"592:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )? | '.' ( '0' .. '9' )+ ( Exponent )? | ( '0' .. '9' )+ Exponent );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa13_eot,	    /* EOT table			    */
	    dfa13_eof,	    /* EOF table			    */
	    dfa13_min,	    /* Minimum tokens for each state    */
	    dfa13_max,	    /* Maximum tokens for each state    */
	    dfa13_accept,	/* Accept table			    */
	    dfa13_special,	/* Special transition states	    */
	    dfa13_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 13
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( PACKAGELITERAL | IMPORTLITERAL | DOT | MESSAGE | EXTEND | EXTENSIONS | RESERVE | TO | ENUM | FLAGS8 | FLAGS16 | FLAGS32 | FLAGS64 | REQUIRED | PBJOPTIONAL | REPEATED | DEFAULT | EQUALS | BLOCK_OPEN | BLOCK_CLOSE | ITEM_TERMINATOR | UINT8 | INT8 | SINT8 | FIXED8 | SFIXED8 | UINT16 | INT16 | SINT16 | FIXED16 | SFIXED16 | UINT32 | INT32 | SINT32 | FIXED32 | SFIXED32 | UINT64 | INT64 | SINT64 | FIXED64 | SFIXED64 | FLOAT | DOUBLE | BOOL | BYTES | STRING | UUID | SHA256 | ANGLE | SOLIDANGLE | TIME | DURATION | NORMAL | VECTOR2F | VECTOR2D | VECTOR3F | VECTOR3D | VECTOR4F | VECTOR4D | QUATERNION | BOUNDINGSPHERE3F | BOUNDINGSPHERE3D | BOUNDINGBOX3F3F | BOUNDINGBOX3D3F | SQBRACKET_OPEN | SQBRACKET_CLOSE | STRING_LITERAL | BOOL_LITERAL | HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOATING_POINT_LITERAL | IDENTIFIER | QUALIFIEDIDENTIFIER | COMMENT | WS );
 */
static const ANTLR3_INT32 dfa24_eot[336] =
    {
	-1, 32, 32, 36, 32, 32, 32, 32, 32, 32, 32, -1, -1, -1, -1, 32, 32, 32, 
	32, 32, 32, 32, -1, -1, -1, 67, 67, 32, -1, -1, 32, 32, -1, -1, 32, 32, 
	-1, -1, 32, 32, 32, 32, 78, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, -1, 103, -1, 67, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, -1, 32, 32, 142, 32, 
	32, 32, 32, 32, 148, 32, 32, 32, 152, 153, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 166, 32, 32, 32, 32, 32, 175, 32, 32, 32, 32, 32, 32, 32, 32, -1, 
	184, 185, 186, 32, 32, -1, 32, 32, 32, -1, -1, 32, 197, 32, 153, 32, 32, 
	32, 32, 206, 32, 32, 32, -1, 210, 32, 32, 32, 32, 32, 32, 32, -1, 32, 219, 
	220, 32, 32, 32, 32, 225, -1, -1, -1, 32, 227, 32, 32, 32, 32, 232, 32, 
	32, 32, -1, 236, 32, 32, 32, 32, 32, 242, 32, -1, 244, 245, 246, -1, 247, 
	248, 249, 32, 254, 255, 32, 32, -1, -1, 258, 32, 32, 263, -1, 264, -1, 
	32, 266, 32, 32, -1, 269, 270, 271, -1, 272, 273, 274, 32, 276, -1, 32, 
	-1, -1, -1, -1, -1, -1, 278, 32, 32, 32, -1, -1, 32, 32, -1, 32, 32, 32, 
	32, -1, -1, 32, -1, 292, 293, -1, -1, -1, -1, -1, -1, 294, -1, 295, -1, 
	296, 297, 298, 32, 32, 302, 303, 304, 305, 306, 307, 32, 32, -1, -1, -1, 
	-1, -1, -1, -1, 32, 32, 32, -1, -1, -1, -1, -1, -1, 32, 314, 315, 32, 32, 
	318, -1, -1, 32, 32, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 332, 333, 
	334, 335, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa24_eof[336] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa24_min[336] =
    {
	9, 46, 46, 48, 46, 46, 46, 46, 46, 46, 46, -1, -1, -1, -1, 46, 46, 46, 
	46, 46, 46, 46, -1, -1, -1, 46, 46, 46, -1, -1, 46, 46, -1, -1, 46, 46, 
	-1, -1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
	46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, -1, 46, -1, 46, 46, 46, 46, 
	46, 46, 46, 46, 46, 46, -1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
	46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, -1, 46, 46, 46, 46, 
	46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
	46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, -1, 46, 
	46, 46, 46, 46, -1, 46, 46, 46, -1, -1, 46, 46, 46, 46, 46, 46, 46, 46, 
	46, 46, 46, 46, -1, 46, 46, 46, 46, 46, 46, 46, 46, -1, 46, 46, 46, 46, 
	46, 46, 46, 46, -1, -1, -1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, -1, 
	46, 46, 46, 46, 46, 46, 46, 46, -1, 46, 46, 46, -1, 46, 46, 46, 46, 46, 
	46, 46, 46, -1, -1, 46, 46, 46, 46, -1, 46, -1, 46, 46, 46, 46, -1, 46, 
	46, 46, -1, 46, 46, 46, 46, 46, -1, 46, -1, -1, -1, -1, -1, -1, 46, 46, 
	46, 46, -1, -1, 46, 46, -1, 46, 46, 46, 46, -1, -1, 46, -1, 46, 46, -1, 
	-1, -1, -1, -1, -1, 46, -1, 46, -1, 46, 46, 46, 46, 46, 46, 46, 46, 46, 
	46, 46, 46, 46, -1, -1, -1, -1, -1, -1, -1, 46, 46, 46, -1, -1, -1, -1, 
	-1, -1, 46, 46, 46, 46, 46, 46, -1, -1, 46, 46, -1, 46, 46, 46, 46, 46, 
	46, 46, 46, 46, 46, 46, 46, 46, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa24_max[336] =
    {
	125, 122, 122, 57, 122, 122, 122, 122, 122, 122, 122, -1, -1, -1, -1, 122, 
	122, 122, 122, 122, 122, 122, -1, -1, -1, 120, 101, 122, -1, -1, 122, 122, 
	-1, -1, 122, 122, -1, -1, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
	122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
	122, 122, 122, -1, 101, -1, 101, 122, 122, 122, 122, 122, 122, 122, 122, 
	122, -1, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
	122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, -1, 122, 122, 122, 
	122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
	122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
	122, 122, 122, 122, 122, -1, 122, 122, 122, 122, 122, -1, 122, 122, 122, 
	-1, -1, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, -1, 
	122, 122, 122, 122, 122, 122, 122, 122, -1, 122, 122, 122, 122, 122, 122, 
	122, 122, -1, -1, -1, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
	-1, 122, 122, 122, 122, 122, 122, 122, 122, -1, 122, 122, 122, -1, 122, 
	122, 122, 122, 122, 122, 122, 122, -1, -1, 122, 122, 122, 122, -1, 122, 
	-1, 122, 122, 122, 122, -1, 122, 122, 122, -1, 122, 122, 122, 122, 122, 
	-1, 122, -1, -1, -1, -1, -1, -1, 122, 122, 122, 122, -1, -1, 122, 122, 
	-1, 122, 122, 122, 122, -1, -1, 122, -1, 122, 122, -1, -1, -1, -1, -1, 
	-1, 122, -1, 122, -1, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
	122, 122, 122, -1, -1, -1, -1, -1, -1, -1, 122, 122, 122, -1, -1, -1, -1, 
	-1, -1, 122, 122, 122, 122, 122, 122, -1, -1, 122, 122, -1, 122, 122, 122, 
	122, 122, 122, 122, 122, 122, 122, 122, 122, 122, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa24_accept[336] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, 19, 20, 21, -1, -1, -1, 
	-1, -1, -1, -1, 65, 66, 67, -1, -1, -1, 75, 76, -1, -1, 73, 74, -1, -1, 
	3, 72, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, 70, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, 
	-1, -1, -1, -1, 9, -1, -1, -1, 51, 68, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, -1, 
	-1, -1, -1, -1, 28, 33, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 42, 
	-1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, 24, -1, -1, -1, -1, -1, 
	-1, -1, -1, 45, 49, -1, -1, -1, -1, 2, -1, 5, -1, -1, -1, -1, 10, -1, -1, 
	-1, 25, -1, -1, -1, -1, -1, 43, -1, 27, 32, 37, 29, 34, 39, -1, -1, -1, 
	-1, 46, 48, -1, -1, 53, -1, -1, -1, -1, 1, 4, -1, 7, -1, -1, 11, 12, 13, 
	30, 35, 40, -1, 17, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 14, 16, 15, 52, 31, 36, 41, -1, -1, -1, 54, 55, 56, 57, 58, 59, 
	-1, -1, -1, -1, -1, -1, 6, 50, -1, -1, 60, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 63, 64, 61, 62
    };
static const ANTLR3_INT32 dfa24_special[336] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa24_T_empty	    NULL

static const ANTLR3_INT32 dfa24_T0[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T1[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 221, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T2[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 100, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T3[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 137, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T4[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 179, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T5[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	289, 31, 288, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T6[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 205, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T7[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 161, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T8[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 277, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T9[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 243, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T10[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 125, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T11[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 88, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T12[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 116, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T13[] =
    {
	37, -1, 66, 66, 66, 66, 66, 66, 66, 66, 37, 37, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 37
    };static const ANTLR3_INT32 dfa24_T14[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 59, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 60, 31
    };static const ANTLR3_INT32 dfa24_T15[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	287, 31, 286, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T16[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 309, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T17[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 265, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T18[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 102, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T19[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 291, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T20[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 139, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T21[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 181, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T22[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 223, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T23[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 228, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T24[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 64, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T25[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	285, 31, 284, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T26[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 129, 31, 31
    };static const ANTLR3_INT32 dfa24_T27[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 92, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T28[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 43, 31, 31, 31, 31, 31, 42, 31, 31, 44, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T29[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 226, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T30[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 187, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T31[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 146, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T32[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 110, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T33[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 30, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T34[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 72, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T35[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 183, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T36[] =
    {
	33, -1, 31, 251, 31, 252, 31, 31, 253, 31, 250, 31, -1, -1, -1, -1, -1, 
	-1, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T37[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 38, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T38[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 70, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T39[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 105, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T40[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 141, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T41[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	214, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T42[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 171, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T43[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 140, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T44[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 104, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T45[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 224, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T46[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 182, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T47[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 69, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T48[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 313, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T49[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 308, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T50[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 290, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T51[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 262, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T52[] =
    {
	33, -1, 31, 31, 31, 31, 235, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T53[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 328, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T54[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 91, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T55[] =
    {
	33, -1, 31, 31, 31, 325, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T56[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 128, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T57[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 40, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 39, 31, 31
    };static const ANTLR3_INT32 dfa24_T58[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 233, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T59[] =
    {
	33, -1, 31, 168, 31, 169, 31, 31, 170, 31, 167, 31, -1, -1, -1, -1, -1, 
	-1, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T60[] =
    {
	33, -1, 31, 31, 234, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T61[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 74, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T62[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 112, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T63[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 83, 31, 31
    };static const ANTLR3_INT32 dfa24_T64[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	176, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T65[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 113, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T66[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 62, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T67[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 120, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T68[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 134, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T69[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 149, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T70[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	190, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T71[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 229, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T72[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 257, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T73[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	156, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T74[] =
    {
	33, -1, 31, 31, 31, 326, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T75[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 329, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T76[] =
    {
	33, -1, 31, 199, 31, 200, 31, 31, 201, 31, 198, 31, -1, -1, -1, -1, -1, 
	-1, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T77[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 218, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T78[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 117, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T79[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 80, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T80[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 283, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T81[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 77, 76, 31, 75, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T82[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 84, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T83[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 157, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T84[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 301, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 300, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T85[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 121, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T86[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 89, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T87[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 63, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T88[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 138, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T89[] =
    {
	33, -1, 31, 163, 31, 164, 31, 31, 165, 31, 162, 31, -1, -1, -1, -1, -1, 
	-1, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T90[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 241, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T91[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 159, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T92[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 126, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T93[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 203, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T94[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 86, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T95[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 123, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T96[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 101, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T97[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 52, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 53, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T98[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 61, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T99[] =
    {
	33, -1, 31, 31, 259, 260, 261, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, 
	-1, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T100[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 151, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T101[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 115, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T102[] =
    {
	37, -1, 66, 66, 66, 66, 66, 66, 66, 66, 37, 37, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 65
    };static const ANTLR3_INT32 dfa24_T103[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 222, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T104[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 96, 31, 31, 31, 31, 31, 97, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T105[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 231, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T106[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 180, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T107[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 192, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T108[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	268, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T109[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	267, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T110[] =
    {
	33, -1, 31, 107, 31, 108, 31, 31, 109, 31, 106, 31, -1, -1, -1, -1, -1, 
	-1, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T111[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 114, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T112[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 150, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T113[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 71, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T114[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 191, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T115[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 230, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T116[] =
    {
	37, 37, 37, 37, 37, 37, 37, 37, 37, 37
    };static const ANTLR3_INT32 dfa24_T117[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 158, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T118[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 202, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T119[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 240, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T120[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 275, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T121[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 85, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T122[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 122, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T123[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 34, 35, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T124[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 81, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 82, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T125[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 143, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T126[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 207, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T127[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 73, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T128[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 211, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T129[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 317, 31, 31
    };static const ANTLR3_INT32 dfa24_T130[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 154, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T131[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 312, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T132[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 279, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T133[] =
    {
	33, -1, 31, 194, 31, 195, 31, 31, 196, 31, 193, 31, -1, -1, -1, -1, -1, 
	-1, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T134[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 147, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T135[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 237, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T136[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 111, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T137[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 118, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T138[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	188, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 189, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T139[] =
    {
	33, -1, 31, 31, 144, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T140[] =
    {
	37, -1, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 37
    };static const ANTLR3_INT32 dfa24_T141[] =
    {
	33, -1, 31, 31, 208, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T142[] =
    {
	33, -1, 31, 31, 212, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T143[] =
    {
	33, -1, 31, 31, 280, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T144[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 55, 31, 57, 54, 31, 31, 31, 31, 31, 58, 31, 31, 31, 31, 56, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T145[] =
    {
	33, -1, 31, 31, 238, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T146[] =
    {
	33, -1, 31, 31, 31, 320, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T147[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	323, 31, 322, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T148[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 316, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T149[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 311, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T150[] =
    {
	33, -1, 31, 31, 31, 31, 209, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T151[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 321, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T152[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 319, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T153[] =
    {
	33, -1, 31, 31, 31, 327, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T154[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 324, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T155[] =
    {
	33, -1, 31, 31, 31, 31, 145, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T156[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	331, 31, 330, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T157[] =
    {
	33, -1, 31, 31, 31, 31, 213, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T158[] =
    {
	33, -1, 31, 31, 31, 31, 239, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T159[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 49, 31, 31, 31, 31, 31, 31, 31, 31, 31, 50, 31, 31, 31, 31, 31, 51, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T160[] =
    {
	33, -1, 31, 31, 31, 31, 281, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T161[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 155, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T162[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 119, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T163[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 204, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T164[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 87, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T165[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 160, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T166[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 124, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T167[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 133, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T168[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 48, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T169[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 135, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T170[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 177, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T171[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 98, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T172[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 172, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T173[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 130, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T174[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 93, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T175[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 215, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T176[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	127, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T177[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 90, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T178[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 94, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T179[] =
    {
	33, -1, 31, 31, 131, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T180[] =
    {
	33, -1, 31, 31, 31, 31, 31, 173, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T181[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 47, 31, 31, 
	31, 31, 31, 31, 31, 46, 31, 31, 45, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T182[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 216, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T183[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 41, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T184[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 99, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T185[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 136, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T186[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 178, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T187[] =
    {
	29, 29, -1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 29, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3, 28, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, -1, 14, -1, 11, -1, 
	-1, -1, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 
	27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 22, -1, 23, -1, 27, -1, 18, 17, 
	27, 10, 5, 8, 27, 27, 2, 27, 27, 27, 4, 19, 9, 1, 21, 6, 16, 7, 15, 20, 
	27, 27, 27, 27, 12, -1, 13
    };static const ANTLR3_INT32 dfa24_T188[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 132, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T189[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 95, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T190[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 217, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T191[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	174, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T192[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 282, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T193[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 256, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T194[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 310, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T195[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 299, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };static const ANTLR3_INT32 dfa24_T196[] =
    {
	33, -1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, -1, -1, 
	-1, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, -1, -1, -1, -1, 31, -1, 31, 31, 31, 
	31, 31, 31, 31, 31, 31, 31, 31, 31, 79, 31, 31, 31, 31, 31, 31, 31, 31, 
	31, 31, 31, 31, 31
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa24_transitions[] =
{
    dfa24_T187, dfa24_T33, dfa24_T123, dfa24_T116, dfa24_T37, dfa24_T57, 
    dfa24_T183, dfa24_T28, dfa24_T181, dfa24_T168, dfa24_T159, dfa24_T_empty, 
    dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T97, dfa24_T144, 
    dfa24_T14, dfa24_T98, dfa24_T66, dfa24_T87, dfa24_T24, dfa24_T_empty, 
    dfa24_T_empty, dfa24_T_empty, dfa24_T102, dfa24_T140, dfa24_T0, dfa24_T_empty, 
    dfa24_T_empty, dfa24_T47, dfa24_T0, dfa24_T_empty, dfa24_T_empty, dfa24_T38, 
    dfa24_T113, dfa24_T_empty, dfa24_T_empty, dfa24_T34, dfa24_T127, dfa24_T61, 
    dfa24_T81, dfa24_T0, dfa24_T196, dfa24_T79, dfa24_T124, dfa24_T63, dfa24_T82, 
    dfa24_T121, dfa24_T94, dfa24_T164, dfa24_T11, dfa24_T86, dfa24_T177, 
    dfa24_T54, dfa24_T27, dfa24_T174, dfa24_T178, dfa24_T189, dfa24_T104, 
    dfa24_T171, dfa24_T184, dfa24_T2, dfa24_T96, dfa24_T18, dfa24_T_empty, 
    dfa24_T13, dfa24_T_empty, dfa24_T140, dfa24_T44, dfa24_T39, dfa24_T110, 
    dfa24_T32, dfa24_T136, dfa24_T62, dfa24_T65, dfa24_T111, dfa24_T101, 
    dfa24_T_empty, dfa24_T12, dfa24_T78, dfa24_T137, dfa24_T162, dfa24_T67, 
    dfa24_T85, dfa24_T122, dfa24_T95, dfa24_T166, dfa24_T10, dfa24_T92, 
    dfa24_T176, dfa24_T56, dfa24_T26, dfa24_T173, dfa24_T179, dfa24_T188, 
    dfa24_T167, dfa24_T68, dfa24_T169, dfa24_T185, dfa24_T3, dfa24_T88, 
    dfa24_T20, dfa24_T_empty, dfa24_T43, dfa24_T40, dfa24_T0, dfa24_T125, 
    dfa24_T139, dfa24_T155, dfa24_T31, dfa24_T134, dfa24_T0, dfa24_T69, 
    dfa24_T112, dfa24_T100, dfa24_T0, dfa24_T0, dfa24_T130, dfa24_T161, 
    dfa24_T73, dfa24_T83, dfa24_T117, dfa24_T91, dfa24_T165, dfa24_T7, dfa24_T89, 
    dfa24_T0, dfa24_T59, dfa24_T42, dfa24_T172, dfa24_T180, dfa24_T191, 
    dfa24_T0, dfa24_T64, dfa24_T170, dfa24_T186, dfa24_T4, dfa24_T106, dfa24_T21, 
    dfa24_T46, dfa24_T35, dfa24_T_empty, dfa24_T0, dfa24_T0, dfa24_T0, dfa24_T30, 
    dfa24_T138, dfa24_T_empty, dfa24_T70, dfa24_T114, dfa24_T107, dfa24_T_empty, 
    dfa24_T_empty, dfa24_T133, dfa24_T0, dfa24_T76, dfa24_T0, dfa24_T118, 
    dfa24_T93, dfa24_T163, dfa24_T6, dfa24_T0, dfa24_T126, dfa24_T141, dfa24_T150, 
    dfa24_T_empty, dfa24_T0, dfa24_T128, dfa24_T142, dfa24_T157, dfa24_T41, 
    dfa24_T175, dfa24_T182, dfa24_T190, dfa24_T_empty, dfa24_T77, dfa24_T0, 
    dfa24_T0, dfa24_T1, dfa24_T103, dfa24_T22, dfa24_T45, dfa24_T0, dfa24_T_empty, 
    dfa24_T_empty, dfa24_T_empty, dfa24_T29, dfa24_T0, dfa24_T23, dfa24_T71, 
    dfa24_T115, dfa24_T105, dfa24_T0, dfa24_T58, dfa24_T60, dfa24_T52, dfa24_T_empty, 
    dfa24_T0, dfa24_T135, dfa24_T145, dfa24_T158, dfa24_T119, dfa24_T90, 
    dfa24_T0, dfa24_T9, dfa24_T_empty, dfa24_T0, dfa24_T0, dfa24_T0, dfa24_T_empty, 
    dfa24_T0, dfa24_T0, dfa24_T0, dfa24_T36, dfa24_T0, dfa24_T0, dfa24_T193, 
    dfa24_T72, dfa24_T_empty, dfa24_T_empty, dfa24_T0, dfa24_T99, dfa24_T51, 
    dfa24_T0, dfa24_T_empty, dfa24_T0, dfa24_T_empty, dfa24_T17, dfa24_T0, 
    dfa24_T109, dfa24_T108, dfa24_T_empty, dfa24_T0, dfa24_T0, dfa24_T0, 
    dfa24_T_empty, dfa24_T0, dfa24_T0, dfa24_T0, dfa24_T120, dfa24_T0, dfa24_T_empty, 
    dfa24_T8, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, 
    dfa24_T_empty, dfa24_T_empty, dfa24_T0, dfa24_T132, dfa24_T143, dfa24_T160, 
    dfa24_T_empty, dfa24_T_empty, dfa24_T192, dfa24_T80, dfa24_T_empty, 
    dfa24_T25, dfa24_T15, dfa24_T5, dfa24_T50, dfa24_T_empty, dfa24_T_empty, 
    dfa24_T19, dfa24_T_empty, dfa24_T0, dfa24_T0, dfa24_T_empty, dfa24_T_empty, 
    dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T0, 
    dfa24_T_empty, dfa24_T0, dfa24_T_empty, dfa24_T0, dfa24_T0, dfa24_T0, 
    dfa24_T195, dfa24_T84, dfa24_T0, dfa24_T0, dfa24_T0, dfa24_T0, dfa24_T0, 
    dfa24_T0, dfa24_T49, dfa24_T16, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, 
    dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T194, 
    dfa24_T149, dfa24_T131, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, 
    dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T48, dfa24_T0, dfa24_T0, 
    dfa24_T148, dfa24_T129, dfa24_T0, dfa24_T_empty, dfa24_T_empty, dfa24_T152, 
    dfa24_T146, dfa24_T_empty, dfa24_T151, dfa24_T147, dfa24_T154, dfa24_T55, 
    dfa24_T74, dfa24_T153, dfa24_T53, dfa24_T75, dfa24_T156, dfa24_T0, dfa24_T0, 
    dfa24_T0, dfa24_T0, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty, dfa24_T_empty	
};


/* Declare tracking structure for Cyclic DFA 24
 */
static
ANTLR3_CYCLIC_DFA cdfa24
    =	{
	    24,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( PACKAGELITERAL | IMPORTLITERAL | DOT | MESSAGE | EXTEND | EXTENSIONS | RESERVE | TO | ENUM | FLAGS8 | FLAGS16 | FLAGS32 | FLAGS64 | REQUIRED | PBJOPTIONAL | REPEATED | DEFAULT | EQUALS | BLOCK_OPEN | BLOCK_CLOSE | ITEM_TERMINATOR | UINT8 | INT8 | SINT8 | FIXED8 | SFIXED8 | UINT16 | INT16 | SINT16 | FIXED16 | SFIXED16 | UINT32 | INT32 | SINT32 | FIXED32 | SFIXED32 | UINT64 | INT64 | SINT64 | FIXED64 | SFIXED64 | FLOAT | DOUBLE | BOOL | BYTES | STRING | UUID | SHA256 | ANGLE | SOLIDANGLE | TIME | DURATION | NORMAL | VECTOR2F | VECTOR2D | VECTOR3F | VECTOR3D | VECTOR4F | VECTOR4D | QUATERNION | BOUNDINGSPHERE3F | BOUNDINGSPHERE3D | BOUNDINGBOX3F3F | BOUNDINGBOX3D3F | SQBRACKET_OPEN | SQBRACKET_CLOSE | STRING_LITERAL | BOOL_LITERAL | HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOATING_POINT_LITERAL | IDENTIFIER | QUALIFIEDIDENTIFIER | COMMENT | WS );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa24_eot,	    /* EOT table			    */
	    dfa24_eof,	    /* EOF table			    */
	    dfa24_min,	    /* Minimum tokens for each state    */
	    dfa24_max,	    /* Maximum tokens for each state    */
	    dfa24_accept,	/* Accept table			    */
	    dfa24_special,	/* Special transition states	    */
	    dfa24_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 24
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 455:16: ( 'package' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PACKAGELITERAL
 *
 * Looks to match the characters the constitute the token PACKAGELITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPACKAGELITERAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PACKAGELITERAL;
       
    
    // PBJ.g:455:16: ( 'package' )
    // PBJ.g:455:21: 'package'
    {
        MATCHS(lit_1); 
        if  (HASEXCEPTION())
        {
            goto rulePACKAGELITERALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePACKAGELITERALEx; /* Prevent compiler warnings */
    rulePACKAGELITERALEx: ;

}
// $ANTLR end PACKAGELITERAL

//   Comes from: 456:15: ( 'import' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IMPORTLITERAL
 *
 * Looks to match the characters the constitute the token IMPORTLITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIMPORTLITERAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IMPORTLITERAL;
       
    
    // PBJ.g:456:15: ( 'import' )
    // PBJ.g:456:21: 'import'
    {
        MATCHS(lit_2); 
        if  (HASEXCEPTION())
        {
            goto ruleIMPORTLITERALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIMPORTLITERALEx; /* Prevent compiler warnings */
    ruleIMPORTLITERALEx: ;

}
// $ANTLR end IMPORTLITERAL

//   Comes from: 458:5: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOT
 *
 * Looks to match the characters the constitute the token DOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOT(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOT;
       
    
    // PBJ.g:458:5: ( '.' )
    // PBJ.g:458:8: '.'
    {
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleDOTEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDOTEx; /* Prevent compiler warnings */
    ruleDOTEx: ;

}
// $ANTLR end DOT

//   Comes from: 461:9: ( 'message' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MESSAGE
 *
 * Looks to match the characters the constitute the token MESSAGE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMESSAGE(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MESSAGE;
       
    
    // PBJ.g:461:9: ( 'message' )
    // PBJ.g:461:11: 'message'
    {
        MATCHS(lit_3); 
        if  (HASEXCEPTION())
        {
            goto ruleMESSAGEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleMESSAGEEx; /* Prevent compiler warnings */
    ruleMESSAGEEx: ;

}
// $ANTLR end MESSAGE

//   Comes from: 462:8: ( 'extend' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXTEND
 *
 * Looks to match the characters the constitute the token EXTEND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXTEND(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXTEND;
       
    
    // PBJ.g:462:8: ( 'extend' )
    // PBJ.g:462:10: 'extend'
    {
        MATCHS(lit_4); 
        if  (HASEXCEPTION())
        {
            goto ruleEXTENDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXTENDEx; /* Prevent compiler warnings */
    ruleEXTENDEx: ;

}
// $ANTLR end EXTEND

//   Comes from: 463:12: ( 'extensions' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXTENSIONS
 *
 * Looks to match the characters the constitute the token EXTENSIONS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXTENSIONS(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXTENSIONS;
       
    
    // PBJ.g:463:12: ( 'extensions' )
    // PBJ.g:463:14: 'extensions'
    {
        MATCHS(lit_5); 
        if  (HASEXCEPTION())
        {
            goto ruleEXTENSIONSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXTENSIONSEx; /* Prevent compiler warnings */
    ruleEXTENSIONSEx: ;

}
// $ANTLR end EXTENSIONS

//   Comes from: 464:9: ( 'reserve' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RESERVE
 *
 * Looks to match the characters the constitute the token RESERVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRESERVE(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RESERVE;
       
    
    // PBJ.g:464:9: ( 'reserve' )
    // PBJ.g:464:11: 'reserve'
    {
        MATCHS(lit_6); 
        if  (HASEXCEPTION())
        {
            goto ruleRESERVEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleRESERVEEx; /* Prevent compiler warnings */
    ruleRESERVEEx: ;

}
// $ANTLR end RESERVE

//   Comes from: 465:4: ( 'to' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TO
 *
 * Looks to match the characters the constitute the token TO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTO(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TO;
       
    
    // PBJ.g:465:4: ( 'to' )
    // PBJ.g:465:6: 'to'
    {
        MATCHS(lit_7); 
        if  (HASEXCEPTION())
        {
            goto ruleTOEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTOEx; /* Prevent compiler warnings */
    ruleTOEx: ;

}
// $ANTLR end TO

//   Comes from: 467:6: ( 'enum' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ENUM
 *
 * Looks to match the characters the constitute the token ENUM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mENUM(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ENUM;
       
    
    // PBJ.g:467:6: ( 'enum' )
    // PBJ.g:467:8: 'enum'
    {
        MATCHS(lit_8); 
        if  (HASEXCEPTION())
        {
            goto ruleENUMEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleENUMEx; /* Prevent compiler warnings */
    ruleENUMEx: ;

}
// $ANTLR end ENUM

//   Comes from: 492:8: ( 'flags8' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLAGS8
 *
 * Looks to match the characters the constitute the token FLAGS8
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLAGS8(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLAGS8;
       
    
    // PBJ.g:492:8: ( 'flags8' )
    // PBJ.g:492:10: 'flags8'
    {
        MATCHS(lit_9); 
        if  (HASEXCEPTION())
        {
            goto ruleFLAGS8Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLAGS8Ex; /* Prevent compiler warnings */
    ruleFLAGS8Ex: ;

}
// $ANTLR end FLAGS8

//   Comes from: 493:9: ( 'flags16' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLAGS16
 *
 * Looks to match the characters the constitute the token FLAGS16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLAGS16(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLAGS16;
       
    
    // PBJ.g:493:9: ( 'flags16' )
    // PBJ.g:493:11: 'flags16'
    {
        MATCHS(lit_10); 
        if  (HASEXCEPTION())
        {
            goto ruleFLAGS16Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLAGS16Ex; /* Prevent compiler warnings */
    ruleFLAGS16Ex: ;

}
// $ANTLR end FLAGS16

//   Comes from: 494:9: ( 'flags32' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLAGS32
 *
 * Looks to match the characters the constitute the token FLAGS32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLAGS32(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLAGS32;
       
    
    // PBJ.g:494:9: ( 'flags32' )
    // PBJ.g:494:11: 'flags32'
    {
        MATCHS(lit_11); 
        if  (HASEXCEPTION())
        {
            goto ruleFLAGS32Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLAGS32Ex; /* Prevent compiler warnings */
    ruleFLAGS32Ex: ;

}
// $ANTLR end FLAGS32

//   Comes from: 495:9: ( 'flags64' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLAGS64
 *
 * Looks to match the characters the constitute the token FLAGS64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLAGS64(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLAGS64;
       
    
    // PBJ.g:495:9: ( 'flags64' )
    // PBJ.g:495:11: 'flags64'
    {
        MATCHS(lit_12); 
        if  (HASEXCEPTION())
        {
            goto ruleFLAGS64Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLAGS64Ex; /* Prevent compiler warnings */
    ruleFLAGS64Ex: ;

}
// $ANTLR end FLAGS64

//   Comes from: 498:9: ( 'required' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REQUIRED
 *
 * Looks to match the characters the constitute the token REQUIRED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREQUIRED(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REQUIRED;
       
    
    // PBJ.g:498:9: ( 'required' )
    // PBJ.g:498:11: 'required'
    {
        MATCHS(lit_13); 
        if  (HASEXCEPTION())
        {
            goto ruleREQUIREDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleREQUIREDEx; /* Prevent compiler warnings */
    ruleREQUIREDEx: ;

}
// $ANTLR end REQUIRED

//   Comes from: 499:12: ( 'optional' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PBJOPTIONAL
 *
 * Looks to match the characters the constitute the token PBJOPTIONAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPBJOPTIONAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PBJOPTIONAL;
       
    
    // PBJ.g:499:12: ( 'optional' )
    // PBJ.g:499:14: 'optional'
    {
        MATCHS(lit_14); 
        if  (HASEXCEPTION())
        {
            goto rulePBJOPTIONALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePBJOPTIONALEx; /* Prevent compiler warnings */
    rulePBJOPTIONALEx: ;

}
// $ANTLR end PBJOPTIONAL

//   Comes from: 500:9: ( 'repeated' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REPEATED
 *
 * Looks to match the characters the constitute the token REPEATED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREPEATED(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REPEATED;
       
    
    // PBJ.g:500:9: ( 'repeated' )
    // PBJ.g:500:11: 'repeated'
    {
        MATCHS(lit_15); 
        if  (HASEXCEPTION())
        {
            goto ruleREPEATEDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleREPEATEDEx; /* Prevent compiler warnings */
    ruleREPEATEDEx: ;

}
// $ANTLR end REPEATED

//   Comes from: 502:9: ( 'default' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DEFAULT
 *
 * Looks to match the characters the constitute the token DEFAULT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDEFAULT(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DEFAULT;
       
    
    // PBJ.g:502:9: ( 'default' )
    // PBJ.g:502:11: 'default'
    {
        MATCHS(lit_16); 
        if  (HASEXCEPTION())
        {
            goto ruleDEFAULTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDEFAULTEx; /* Prevent compiler warnings */
    ruleDEFAULTEx: ;

}
// $ANTLR end DEFAULT

//   Comes from: 505:8: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUALS
 *
 * Looks to match the characters the constitute the token EQUALS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEQUALS(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EQUALS;
       
    
    // PBJ.g:505:8: ( '=' )
    // PBJ.g:505:10: '='
    {
        MATCHC('='); 
        if  (HASEXCEPTION())
        {
            goto ruleEQUALSEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEQUALSEx; /* Prevent compiler warnings */
    ruleEQUALSEx: ;

}
// $ANTLR end EQUALS

//   Comes from: 508:12: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BLOCK_OPEN
 *
 * Looks to match the characters the constitute the token BLOCK_OPEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBLOCK_OPEN(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BLOCK_OPEN;
       
    
    // PBJ.g:508:12: ( '{' )
    // PBJ.g:508:14: '{'
    {
        MATCHC('{'); 
        if  (HASEXCEPTION())
        {
            goto ruleBLOCK_OPENEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBLOCK_OPENEx; /* Prevent compiler warnings */
    ruleBLOCK_OPENEx: ;

}
// $ANTLR end BLOCK_OPEN

//   Comes from: 509:13: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BLOCK_CLOSE
 *
 * Looks to match the characters the constitute the token BLOCK_CLOSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBLOCK_CLOSE(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BLOCK_CLOSE;
       
    
    // PBJ.g:509:13: ( '}' )
    // PBJ.g:509:15: '}'
    {
        MATCHC('}'); 
        if  (HASEXCEPTION())
        {
            goto ruleBLOCK_CLOSEEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBLOCK_CLOSEEx; /* Prevent compiler warnings */
    ruleBLOCK_CLOSEEx: ;

}
// $ANTLR end BLOCK_CLOSE

//   Comes from: 512:2: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ITEM_TERMINATOR
 *
 * Looks to match the characters the constitute the token ITEM_TERMINATOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mITEM_TERMINATOR(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ITEM_TERMINATOR;
       
    
    // PBJ.g:512:2: ( ';' )
    // PBJ.g:512:4: ';'
    {
        MATCHC(';'); 
        if  (HASEXCEPTION())
        {
            goto ruleITEM_TERMINATOREx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleITEM_TERMINATOREx; /* Prevent compiler warnings */
    ruleITEM_TERMINATOREx: ;

}
// $ANTLR end ITEM_TERMINATOR

//   Comes from: 515:7: ( 'uint8' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UINT8
 *
 * Looks to match the characters the constitute the token UINT8
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUINT8(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UINT8;
       
    
    // PBJ.g:515:7: ( 'uint8' )
    // PBJ.g:515:9: 'uint8'
    {
        MATCHS(lit_17); 
        if  (HASEXCEPTION())
        {
            goto ruleUINT8Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleUINT8Ex; /* Prevent compiler warnings */
    ruleUINT8Ex: ;

}
// $ANTLR end UINT8

//   Comes from: 516:6: ( 'int8' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT8
 *
 * Looks to match the characters the constitute the token INT8
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINT8(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INT8;
       
    
    // PBJ.g:516:6: ( 'int8' )
    // PBJ.g:516:8: 'int8'
    {
        MATCHS(lit_18); 
        if  (HASEXCEPTION())
        {
            goto ruleINT8Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINT8Ex; /* Prevent compiler warnings */
    ruleINT8Ex: ;

}
// $ANTLR end INT8

//   Comes from: 517:7: ( 'sint8' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINT8
 *
 * Looks to match the characters the constitute the token SINT8
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSINT8(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SINT8;
       
    
    // PBJ.g:517:7: ( 'sint8' )
    // PBJ.g:517:9: 'sint8'
    {
        MATCHS(lit_19); 
        if  (HASEXCEPTION())
        {
            goto ruleSINT8Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSINT8Ex; /* Prevent compiler warnings */
    ruleSINT8Ex: ;

}
// $ANTLR end SINT8

//   Comes from: 518:8: ( 'fixed8' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FIXED8
 *
 * Looks to match the characters the constitute the token FIXED8
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFIXED8(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FIXED8;
       
    
    // PBJ.g:518:8: ( 'fixed8' )
    // PBJ.g:518:10: 'fixed8'
    {
        MATCHS(lit_20); 
        if  (HASEXCEPTION())
        {
            goto ruleFIXED8Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFIXED8Ex; /* Prevent compiler warnings */
    ruleFIXED8Ex: ;

}
// $ANTLR end FIXED8

//   Comes from: 519:9: ( 'sfixed8' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SFIXED8
 *
 * Looks to match the characters the constitute the token SFIXED8
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSFIXED8(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SFIXED8;
       
    
    // PBJ.g:519:9: ( 'sfixed8' )
    // PBJ.g:519:11: 'sfixed8'
    {
        MATCHS(lit_21); 
        if  (HASEXCEPTION())
        {
            goto ruleSFIXED8Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSFIXED8Ex; /* Prevent compiler warnings */
    ruleSFIXED8Ex: ;

}
// $ANTLR end SFIXED8

//   Comes from: 520:8: ( 'uint16' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UINT16
 *
 * Looks to match the characters the constitute the token UINT16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUINT16(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UINT16;
       
    
    // PBJ.g:520:8: ( 'uint16' )
    // PBJ.g:520:10: 'uint16'
    {
        MATCHS(lit_22); 
        if  (HASEXCEPTION())
        {
            goto ruleUINT16Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleUINT16Ex; /* Prevent compiler warnings */
    ruleUINT16Ex: ;

}
// $ANTLR end UINT16

//   Comes from: 521:7: ( 'int16' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT16
 *
 * Looks to match the characters the constitute the token INT16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINT16(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INT16;
       
    
    // PBJ.g:521:7: ( 'int16' )
    // PBJ.g:521:9: 'int16'
    {
        MATCHS(lit_23); 
        if  (HASEXCEPTION())
        {
            goto ruleINT16Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINT16Ex; /* Prevent compiler warnings */
    ruleINT16Ex: ;

}
// $ANTLR end INT16

//   Comes from: 522:8: ( 'sint16' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINT16
 *
 * Looks to match the characters the constitute the token SINT16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSINT16(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SINT16;
       
    
    // PBJ.g:522:8: ( 'sint16' )
    // PBJ.g:522:10: 'sint16'
    {
        MATCHS(lit_24); 
        if  (HASEXCEPTION())
        {
            goto ruleSINT16Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSINT16Ex; /* Prevent compiler warnings */
    ruleSINT16Ex: ;

}
// $ANTLR end SINT16

//   Comes from: 523:9: ( 'fixed16' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FIXED16
 *
 * Looks to match the characters the constitute the token FIXED16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFIXED16(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FIXED16;
       
    
    // PBJ.g:523:9: ( 'fixed16' )
    // PBJ.g:523:11: 'fixed16'
    {
        MATCHS(lit_25); 
        if  (HASEXCEPTION())
        {
            goto ruleFIXED16Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFIXED16Ex; /* Prevent compiler warnings */
    ruleFIXED16Ex: ;

}
// $ANTLR end FIXED16

//   Comes from: 524:9: ( 'sfixed16' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SFIXED16
 *
 * Looks to match the characters the constitute the token SFIXED16
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSFIXED16(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SFIXED16;
       
    
    // PBJ.g:524:9: ( 'sfixed16' )
    // PBJ.g:524:11: 'sfixed16'
    {
        MATCHS(lit_26); 
        if  (HASEXCEPTION())
        {
            goto ruleSFIXED16Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSFIXED16Ex; /* Prevent compiler warnings */
    ruleSFIXED16Ex: ;

}
// $ANTLR end SFIXED16

//   Comes from: 525:8: ( 'uint32' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UINT32
 *
 * Looks to match the characters the constitute the token UINT32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUINT32(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UINT32;
       
    
    // PBJ.g:525:8: ( 'uint32' )
    // PBJ.g:525:10: 'uint32'
    {
        MATCHS(lit_27); 
        if  (HASEXCEPTION())
        {
            goto ruleUINT32Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleUINT32Ex; /* Prevent compiler warnings */
    ruleUINT32Ex: ;

}
// $ANTLR end UINT32

//   Comes from: 526:7: ( 'int32' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT32
 *
 * Looks to match the characters the constitute the token INT32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINT32(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INT32;
       
    
    // PBJ.g:526:7: ( 'int32' )
    // PBJ.g:526:9: 'int32'
    {
        MATCHS(lit_28); 
        if  (HASEXCEPTION())
        {
            goto ruleINT32Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINT32Ex; /* Prevent compiler warnings */
    ruleINT32Ex: ;

}
// $ANTLR end INT32

//   Comes from: 527:8: ( 'sint32' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINT32
 *
 * Looks to match the characters the constitute the token SINT32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSINT32(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SINT32;
       
    
    // PBJ.g:527:8: ( 'sint32' )
    // PBJ.g:527:10: 'sint32'
    {
        MATCHS(lit_29); 
        if  (HASEXCEPTION())
        {
            goto ruleSINT32Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSINT32Ex; /* Prevent compiler warnings */
    ruleSINT32Ex: ;

}
// $ANTLR end SINT32

//   Comes from: 528:9: ( 'fixed32' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FIXED32
 *
 * Looks to match the characters the constitute the token FIXED32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFIXED32(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FIXED32;
       
    
    // PBJ.g:528:9: ( 'fixed32' )
    // PBJ.g:528:11: 'fixed32'
    {
        MATCHS(lit_30); 
        if  (HASEXCEPTION())
        {
            goto ruleFIXED32Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFIXED32Ex; /* Prevent compiler warnings */
    ruleFIXED32Ex: ;

}
// $ANTLR end FIXED32

//   Comes from: 529:9: ( 'sfixed32' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SFIXED32
 *
 * Looks to match the characters the constitute the token SFIXED32
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSFIXED32(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SFIXED32;
       
    
    // PBJ.g:529:9: ( 'sfixed32' )
    // PBJ.g:529:11: 'sfixed32'
    {
        MATCHS(lit_31); 
        if  (HASEXCEPTION())
        {
            goto ruleSFIXED32Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSFIXED32Ex; /* Prevent compiler warnings */
    ruleSFIXED32Ex: ;

}
// $ANTLR end SFIXED32

//   Comes from: 530:8: ( 'uint64' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UINT64
 *
 * Looks to match the characters the constitute the token UINT64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUINT64(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UINT64;
       
    
    // PBJ.g:530:8: ( 'uint64' )
    // PBJ.g:530:10: 'uint64'
    {
        MATCHS(lit_32); 
        if  (HASEXCEPTION())
        {
            goto ruleUINT64Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleUINT64Ex; /* Prevent compiler warnings */
    ruleUINT64Ex: ;

}
// $ANTLR end UINT64

//   Comes from: 531:7: ( 'int64' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT64
 *
 * Looks to match the characters the constitute the token INT64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINT64(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INT64;
       
    
    // PBJ.g:531:7: ( 'int64' )
    // PBJ.g:531:9: 'int64'
    {
        MATCHS(lit_33); 
        if  (HASEXCEPTION())
        {
            goto ruleINT64Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINT64Ex; /* Prevent compiler warnings */
    ruleINT64Ex: ;

}
// $ANTLR end INT64

//   Comes from: 532:8: ( 'sint64' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINT64
 *
 * Looks to match the characters the constitute the token SINT64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSINT64(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SINT64;
       
    
    // PBJ.g:532:8: ( 'sint64' )
    // PBJ.g:532:10: 'sint64'
    {
        MATCHS(lit_34); 
        if  (HASEXCEPTION())
        {
            goto ruleSINT64Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSINT64Ex; /* Prevent compiler warnings */
    ruleSINT64Ex: ;

}
// $ANTLR end SINT64

//   Comes from: 533:9: ( 'fixed64' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FIXED64
 *
 * Looks to match the characters the constitute the token FIXED64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFIXED64(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FIXED64;
       
    
    // PBJ.g:533:9: ( 'fixed64' )
    // PBJ.g:533:11: 'fixed64'
    {
        MATCHS(lit_35); 
        if  (HASEXCEPTION())
        {
            goto ruleFIXED64Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFIXED64Ex; /* Prevent compiler warnings */
    ruleFIXED64Ex: ;

}
// $ANTLR end FIXED64

//   Comes from: 534:9: ( 'sfixed64' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SFIXED64
 *
 * Looks to match the characters the constitute the token SFIXED64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSFIXED64(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SFIXED64;
       
    
    // PBJ.g:534:9: ( 'sfixed64' )
    // PBJ.g:534:11: 'sfixed64'
    {
        MATCHS(lit_36); 
        if  (HASEXCEPTION())
        {
            goto ruleSFIXED64Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSFIXED64Ex; /* Prevent compiler warnings */
    ruleSFIXED64Ex: ;

}
// $ANTLR end SFIXED64

//   Comes from: 535:7: ( 'float' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT
 *
 * Looks to match the characters the constitute the token FLOAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOAT(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLOAT;
       
    
    // PBJ.g:535:7: ( 'float' )
    // PBJ.g:535:9: 'float'
    {
        MATCHS(lit_37); 
        if  (HASEXCEPTION())
        {
            goto ruleFLOATEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATEx; /* Prevent compiler warnings */
    ruleFLOATEx: ;

}
// $ANTLR end FLOAT

//   Comes from: 536:8: ( 'double' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE
 *
 * Looks to match the characters the constitute the token DOUBLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOUBLE;
       
    
    // PBJ.g:536:8: ( 'double' )
    // PBJ.g:536:10: 'double'
    {
        MATCHS(lit_38); 
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDOUBLEEx; /* Prevent compiler warnings */
    ruleDOUBLEEx: ;

}
// $ANTLR end DOUBLE

//   Comes from: 537:6: ( 'bool' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOOL
 *
 * Looks to match the characters the constitute the token BOOL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOOL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BOOL;
       
    
    // PBJ.g:537:6: ( 'bool' )
    // PBJ.g:537:8: 'bool'
    {
        MATCHS(lit_39); 
        if  (HASEXCEPTION())
        {
            goto ruleBOOLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBOOLEx; /* Prevent compiler warnings */
    ruleBOOLEx: ;

}
// $ANTLR end BOOL

//   Comes from: 538:9: ( 'bytes' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BYTES
 *
 * Looks to match the characters the constitute the token BYTES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBYTES(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BYTES;
       
    
    // PBJ.g:538:9: ( 'bytes' )
    // PBJ.g:538:13: 'bytes'
    {
        MATCHS(lit_40); 
        if  (HASEXCEPTION())
        {
            goto ruleBYTESEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBYTESEx; /* Prevent compiler warnings */
    ruleBYTESEx: ;

}
// $ANTLR end BYTES

//   Comes from: 539:10: ( 'string' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING
 *
 * Looks to match the characters the constitute the token STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING;
       
    
    // PBJ.g:539:10: ( 'string' )
    // PBJ.g:539:14: 'string'
    {
        MATCHS(lit_41); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRINGEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRINGEx; /* Prevent compiler warnings */
    ruleSTRINGEx: ;

}
// $ANTLR end STRING

//   Comes from: 541:6: ( 'uuid' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UUID
 *
 * Looks to match the characters the constitute the token UUID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUUID(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UUID;
       
    
    // PBJ.g:541:6: ( 'uuid' )
    // PBJ.g:541:8: 'uuid'
    {
        MATCHS(lit_42); 
        if  (HASEXCEPTION())
        {
            goto ruleUUIDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleUUIDEx; /* Prevent compiler warnings */
    ruleUUIDEx: ;

}
// $ANTLR end UUID

//   Comes from: 542:8: ( 'sha256' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHA256
 *
 * Looks to match the characters the constitute the token SHA256
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHA256(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHA256;
       
    
    // PBJ.g:542:8: ( 'sha256' )
    // PBJ.g:542:10: 'sha256'
    {
        MATCHS(lit_43); 
        if  (HASEXCEPTION())
        {
            goto ruleSHA256Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSHA256Ex; /* Prevent compiler warnings */
    ruleSHA256Ex: ;

}
// $ANTLR end SHA256

//   Comes from: 543:7: ( 'angle' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ANGLE
 *
 * Looks to match the characters the constitute the token ANGLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mANGLE(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ANGLE;
       
    
    // PBJ.g:543:7: ( 'angle' )
    // PBJ.g:543:9: 'angle'
    {
        MATCHS(lit_44); 
        if  (HASEXCEPTION())
        {
            goto ruleANGLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleANGLEEx; /* Prevent compiler warnings */
    ruleANGLEEx: ;

}
// $ANTLR end ANGLE

//   Comes from: 544:12: ( 'solidangle' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SOLIDANGLE
 *
 * Looks to match the characters the constitute the token SOLIDANGLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSOLIDANGLE(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SOLIDANGLE;
       
    
    // PBJ.g:544:12: ( 'solidangle' )
    // PBJ.g:544:14: 'solidangle'
    {
        MATCHS(lit_45); 
        if  (HASEXCEPTION())
        {
            goto ruleSOLIDANGLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSOLIDANGLEEx; /* Prevent compiler warnings */
    ruleSOLIDANGLEEx: ;

}
// $ANTLR end SOLIDANGLE

//   Comes from: 545:6: ( 'time' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TIME
 *
 * Looks to match the characters the constitute the token TIME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTIME(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TIME;
       
    
    // PBJ.g:545:6: ( 'time' )
    // PBJ.g:545:8: 'time'
    {
        MATCHS(lit_46); 
        if  (HASEXCEPTION())
        {
            goto ruleTIMEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTIMEEx; /* Prevent compiler warnings */
    ruleTIMEEx: ;

}
// $ANTLR end TIME

//   Comes from: 546:10: ( 'duration' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DURATION
 *
 * Looks to match the characters the constitute the token DURATION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDURATION(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DURATION;
       
    
    // PBJ.g:546:10: ( 'duration' )
    // PBJ.g:546:12: 'duration'
    {
        MATCHS(lit_47); 
        if  (HASEXCEPTION())
        {
            goto ruleDURATIONEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDURATIONEx; /* Prevent compiler warnings */
    ruleDURATIONEx: ;

}
// $ANTLR end DURATION

//   Comes from: 547:8: ( 'normal' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NORMAL
 *
 * Looks to match the characters the constitute the token NORMAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNORMAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NORMAL;
       
    
    // PBJ.g:547:8: ( 'normal' )
    // PBJ.g:547:10: 'normal'
    {
        MATCHS(lit_48); 
        if  (HASEXCEPTION())
        {
            goto ruleNORMALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNORMALEx; /* Prevent compiler warnings */
    ruleNORMALEx: ;

}
// $ANTLR end NORMAL

//   Comes from: 548:10: ( 'vector2f' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VECTOR2F
 *
 * Looks to match the characters the constitute the token VECTOR2F
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVECTOR2F(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = VECTOR2F;
       
    
    // PBJ.g:548:10: ( 'vector2f' )
    // PBJ.g:548:12: 'vector2f'
    {
        MATCHS(lit_49); 
        if  (HASEXCEPTION())
        {
            goto ruleVECTOR2FEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleVECTOR2FEx; /* Prevent compiler warnings */
    ruleVECTOR2FEx: ;

}
// $ANTLR end VECTOR2F

//   Comes from: 549:10: ( 'vector2d' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VECTOR2D
 *
 * Looks to match the characters the constitute the token VECTOR2D
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVECTOR2D(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = VECTOR2D;
       
    
    // PBJ.g:549:10: ( 'vector2d' )
    // PBJ.g:549:12: 'vector2d'
    {
        MATCHS(lit_50); 
        if  (HASEXCEPTION())
        {
            goto ruleVECTOR2DEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleVECTOR2DEx; /* Prevent compiler warnings */
    ruleVECTOR2DEx: ;

}
// $ANTLR end VECTOR2D

//   Comes from: 550:10: ( 'vector3f' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VECTOR3F
 *
 * Looks to match the characters the constitute the token VECTOR3F
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVECTOR3F(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = VECTOR3F;
       
    
    // PBJ.g:550:10: ( 'vector3f' )
    // PBJ.g:550:12: 'vector3f'
    {
        MATCHS(lit_51); 
        if  (HASEXCEPTION())
        {
            goto ruleVECTOR3FEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleVECTOR3FEx; /* Prevent compiler warnings */
    ruleVECTOR3FEx: ;

}
// $ANTLR end VECTOR3F

//   Comes from: 551:10: ( 'vector3d' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VECTOR3D
 *
 * Looks to match the characters the constitute the token VECTOR3D
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVECTOR3D(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = VECTOR3D;
       
    
    // PBJ.g:551:10: ( 'vector3d' )
    // PBJ.g:551:12: 'vector3d'
    {
        MATCHS(lit_52); 
        if  (HASEXCEPTION())
        {
            goto ruleVECTOR3DEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleVECTOR3DEx; /* Prevent compiler warnings */
    ruleVECTOR3DEx: ;

}
// $ANTLR end VECTOR3D

//   Comes from: 552:10: ( 'vector4f' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VECTOR4F
 *
 * Looks to match the characters the constitute the token VECTOR4F
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVECTOR4F(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = VECTOR4F;
       
    
    // PBJ.g:552:10: ( 'vector4f' )
    // PBJ.g:552:12: 'vector4f'
    {
        MATCHS(lit_53); 
        if  (HASEXCEPTION())
        {
            goto ruleVECTOR4FEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleVECTOR4FEx; /* Prevent compiler warnings */
    ruleVECTOR4FEx: ;

}
// $ANTLR end VECTOR4F

//   Comes from: 553:10: ( 'vector4d' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VECTOR4D
 *
 * Looks to match the characters the constitute the token VECTOR4D
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVECTOR4D(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = VECTOR4D;
       
    
    // PBJ.g:553:10: ( 'vector4d' )
    // PBJ.g:553:12: 'vector4d'
    {
        MATCHS(lit_54); 
        if  (HASEXCEPTION())
        {
            goto ruleVECTOR4DEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleVECTOR4DEx; /* Prevent compiler warnings */
    ruleVECTOR4DEx: ;

}
// $ANTLR end VECTOR4D

//   Comes from: 554:12: ( 'quaternion' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUATERNION
 *
 * Looks to match the characters the constitute the token QUATERNION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQUATERNION(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = QUATERNION;
       
    
    // PBJ.g:554:12: ( 'quaternion' )
    // PBJ.g:554:14: 'quaternion'
    {
        MATCHS(lit_55); 
        if  (HASEXCEPTION())
        {
            goto ruleQUATERNIONEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleQUATERNIONEx; /* Prevent compiler warnings */
    ruleQUATERNIONEx: ;

}
// $ANTLR end QUATERNION

//   Comes from: 555:18: ( 'boundingsphere3f' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOUNDINGSPHERE3F
 *
 * Looks to match the characters the constitute the token BOUNDINGSPHERE3F
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOUNDINGSPHERE3F(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BOUNDINGSPHERE3F;
       
    
    // PBJ.g:555:18: ( 'boundingsphere3f' )
    // PBJ.g:555:20: 'boundingsphere3f'
    {
        MATCHS(lit_56); 
        if  (HASEXCEPTION())
        {
            goto ruleBOUNDINGSPHERE3FEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBOUNDINGSPHERE3FEx; /* Prevent compiler warnings */
    ruleBOUNDINGSPHERE3FEx: ;

}
// $ANTLR end BOUNDINGSPHERE3F

//   Comes from: 556:18: ( 'boundingsphere3d' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOUNDINGSPHERE3D
 *
 * Looks to match the characters the constitute the token BOUNDINGSPHERE3D
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOUNDINGSPHERE3D(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BOUNDINGSPHERE3D;
       
    
    // PBJ.g:556:18: ( 'boundingsphere3d' )
    // PBJ.g:556:20: 'boundingsphere3d'
    {
        MATCHS(lit_57); 
        if  (HASEXCEPTION())
        {
            goto ruleBOUNDINGSPHERE3DEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBOUNDINGSPHERE3DEx; /* Prevent compiler warnings */
    ruleBOUNDINGSPHERE3DEx: ;

}
// $ANTLR end BOUNDINGSPHERE3D

//   Comes from: 557:17: ( 'boundingbox3f3f' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOUNDINGBOX3F3F
 *
 * Looks to match the characters the constitute the token BOUNDINGBOX3F3F
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOUNDINGBOX3F3F(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BOUNDINGBOX3F3F;
       
    
    // PBJ.g:557:17: ( 'boundingbox3f3f' )
    // PBJ.g:557:19: 'boundingbox3f3f'
    {
        MATCHS(lit_58); 
        if  (HASEXCEPTION())
        {
            goto ruleBOUNDINGBOX3F3FEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBOUNDINGBOX3F3FEx; /* Prevent compiler warnings */
    ruleBOUNDINGBOX3F3FEx: ;

}
// $ANTLR end BOUNDINGBOX3F3F

//   Comes from: 558:17: ( 'boundingbox3d3f' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOUNDINGBOX3D3F
 *
 * Looks to match the characters the constitute the token BOUNDINGBOX3D3F
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOUNDINGBOX3D3F(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BOUNDINGBOX3D3F;
       
    
    // PBJ.g:558:17: ( 'boundingbox3d3f' )
    // PBJ.g:558:19: 'boundingbox3d3f'
    {
        MATCHS(lit_59); 
        if  (HASEXCEPTION())
        {
            goto ruleBOUNDINGBOX3D3FEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBOUNDINGBOX3D3FEx; /* Prevent compiler warnings */
    ruleBOUNDINGBOX3D3FEx: ;

}
// $ANTLR end BOUNDINGBOX3D3F

//   Comes from: 561:16: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQBRACKET_OPEN
 *
 * Looks to match the characters the constitute the token SQBRACKET_OPEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSQBRACKET_OPEN(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SQBRACKET_OPEN;
       
    
    // PBJ.g:561:16: ( '[' )
    // PBJ.g:561:18: '['
    {
        MATCHC('['); 
        if  (HASEXCEPTION())
        {
            goto ruleSQBRACKET_OPENEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSQBRACKET_OPENEx; /* Prevent compiler warnings */
    ruleSQBRACKET_OPENEx: ;

}
// $ANTLR end SQBRACKET_OPEN

//   Comes from: 562:17: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQBRACKET_CLOSE
 *
 * Looks to match the characters the constitute the token SQBRACKET_CLOSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSQBRACKET_CLOSE(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SQBRACKET_CLOSE;
       
    
    // PBJ.g:562:17: ( ']' )
    // PBJ.g:562:19: ']'
    {
        MATCHC(']'); 
        if  (HASEXCEPTION())
        {
            goto ruleSQBRACKET_CLOSEEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSQBRACKET_CLOSEEx; /* Prevent compiler warnings */
    ruleSQBRACKET_CLOSEEx: ;

}
// $ANTLR end SQBRACKET_CLOSE

//   Comes from: 571:5: ( '\"' STRING_GUTS '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL
 *
 * Looks to match the characters the constitute the token STRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING_LITERAL;
       
    
    // PBJ.g:571:5: ( '\"' STRING_GUTS '\"' )
    // PBJ.g:571:8: '\"' STRING_GUTS '\"'
    {
        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }

        /* 571:8: '\"' STRING_GUTS '\"' */
        mSTRING_GUTS(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }

        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERALEx; /* Prevent compiler warnings */
    ruleSTRING_LITERALEx: ;

}
// $ANTLR end STRING_LITERAL

//   Comes from: 575:13: ( ( EscapeSequence | ~ ( '\\\\' | '\"' ) )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_GUTS
 *
 * Looks to match the characters the constitute the token STRING_GUTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_GUTS(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // PBJ.g:575:13: ( ( EscapeSequence | ~ ( '\\\\' | '\"' ) )* )
    // PBJ.g:575:15: ( EscapeSequence | ~ ( '\\\\' | '\"' ) )*
    {

        // PBJ.g:575:15: ( EscapeSequence | ~ ( '\\\\' | '\"' ) )*

        for (;;)
        {
            int alt1=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = LA(1);
                if ( (LA1_0 == '\\') ) 
                {
                    alt1=1;
                }
                else if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '!')) || ((LA1_0 >= '#') && (LA1_0 <= '[')) || ((LA1_0 >= ']') && (LA1_0 <= 0xFFFF))) ) 
                {
                    alt1=2;
                }

            }
            switch (alt1) 
            {
        	case 1:
        	    // PBJ.g:575:17: EscapeSequence
        	    {
        	        /* 575:17: EscapeSequence */
        	        mEscapeSequence(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSTRING_GUTSEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PBJ.g:575:34: ~ ( '\\\\' | '\"' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSTRING_GUTSEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


    }



    // This is where rules clean up and exit
    //
    goto ruleSTRING_GUTSEx; /* Prevent compiler warnings */
    ruleSTRING_GUTSEx: ;

}
// $ANTLR end STRING_GUTS

//   Comes from: 578:5: ( 'true' | 'false' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BOOL_LITERAL
 *
 * Looks to match the characters the constitute the token BOOL_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBOOL_LITERAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BOOL_LITERAL;
       
    
    {
        //  PBJ.g:578:5: ( 'true' | 'false' )
        
        ANTLR3_UINT32 alt2;

        alt2=2;


        {
            int LA2_0 = LA(1);
            if ( (LA2_0 == 't') ) 
            {
                alt2=1;
            }
            else if ( (LA2_0 == 'f') ) 
            {
                alt2=2;
            }
            else 
            {
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto ruleBOOL_LITERALEx;
            }
        }
        switch (alt2) 
        {
    	case 1:
    	    // PBJ.g:578:7: 'true'
    	    {
    	        MATCHS(lit_60); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleBOOL_LITERALEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // PBJ.g:579:7: 'false'
    	    {
    	        MATCHS(lit_61); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleBOOL_LITERALEx;
    	        }



    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBOOL_LITERALEx; /* Prevent compiler warnings */
    ruleBOOL_LITERALEx: ;

}
// $ANTLR end BOOL_LITERAL

//   Comes from: 582:13: ( '0' ( 'x' | 'X' ) ( HexDigit )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_LITERAL
 *
 * Looks to match the characters the constitute the token HEX_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_LITERAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = HEX_LITERAL;
       
    
    // PBJ.g:582:13: ( '0' ( 'x' | 'X' ) ( HexDigit )+ )
    // PBJ.g:582:15: '0' ( 'x' | 'X' ) ( HexDigit )+
    {
        MATCHC('0'); 
        if  (HASEXCEPTION())
        {
            goto ruleHEX_LITERALEx;
        }

        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEX_LITERALEx;
        }

        // PBJ.g:582:29: ( HexDigit )+
        {
            int cnt3=0;

            for (;;)
            {
                int alt3=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA3_0 = LA(1);
        	    if ( (((LA3_0 >= '0') && (LA3_0 <= '9')) || ((LA3_0 >= 'A') && (LA3_0 <= 'F')) || ((LA3_0 >= 'a') && (LA3_0 <= 'f'))) ) 
        	    {
        	        alt3=1;
        	    }

        	}
        	switch (alt3) 
        	{
        	    case 1:
        	        // PBJ.g:582:29: HexDigit
        	        {
        	            /* 582:29: HexDigit */
        	            mHexDigit(ctx ); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleHEX_LITERALEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt3 >= 1 )
        		{
        		    goto loop3;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleHEX_LITERALEx;
        	}
        	cnt3++;
            }
            loop3: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleHEX_LITERALEx; /* Prevent compiler warnings */
    ruleHEX_LITERALEx: ;

}
// $ANTLR end HEX_LITERAL

//   Comes from: 584:17: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_LITERAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_LITERAL;
       
    
    // PBJ.g:584:17: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) )
    // PBJ.g:584:19: ( '0' | '1' .. '9' ( '0' .. '9' )* )
    {

        // PBJ.g:584:19: ( '0' | '1' .. '9' ( '0' .. '9' )* )
        {
            int alt5=2;

            {
                int LA5_0 = LA(1);
                if ( (LA5_0 == '0') ) 
                {
                    alt5=1;
                }
                else if ( (((LA5_0 >= '1') && (LA5_0 <= '9'))) ) 
                {
                    alt5=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 5;
                    EXCEPTION->state        = 0;


                    goto ruleDECIMAL_LITERALEx;
                }
            }
            switch (alt5) 
            {
        	case 1:
        	    // PBJ.g:584:20: '0'
        	    {
        	        MATCHC('0'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_LITERALEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PBJ.g:584:26: '1' .. '9' ( '0' .. '9' )*
        	    {
        	        MATCHRANGE('1', '9'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_LITERALEx;
        	        }


        	        // PBJ.g:584:35: ( '0' .. '9' )*

        	        for (;;)
        	        {
        	            int alt4=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA4_0 = LA(1);
        	                if ( (((LA4_0 >= '0') && (LA4_0 <= '9'))) ) 
        	                {
        	                    alt4=1;
        	                }

        	            }
        	            switch (alt4) 
        	            {
        	        	case 1:
        	        	    // PBJ.g:584:35: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleDECIMAL_LITERALEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop4;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop4: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_LITERALEx: ;

}
// $ANTLR end DECIMAL_LITERAL

//   Comes from: 586:15: ( '0' ( '0' .. '7' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_LITERAL
 *
 * Looks to match the characters the constitute the token OCTAL_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOCTAL_LITERAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OCTAL_LITERAL;
       
    
    // PBJ.g:586:15: ( '0' ( '0' .. '7' )+ )
    // PBJ.g:586:17: '0' ( '0' .. '7' )+
    {
        MATCHC('0'); 
        if  (HASEXCEPTION())
        {
            goto ruleOCTAL_LITERALEx;
        }

        // PBJ.g:586:21: ( '0' .. '7' )+
        {
            int cnt6=0;

            for (;;)
            {
                int alt6=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA6_0 = LA(1);
        	    if ( (((LA6_0 >= '0') && (LA6_0 <= '7'))) ) 
        	    {
        	        alt6=1;
        	    }

        	}
        	switch (alt6) 
        	{
        	    case 1:
        	        // PBJ.g:586:22: '0' .. '7'
        	        {
        	            MATCHRANGE('0', '7'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleOCTAL_LITERALEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt6 >= 1 )
        		{
        		    goto loop6;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleOCTAL_LITERALEx;
        	}
        	cnt6++;
            }
            loop6: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleOCTAL_LITERALEx; /* Prevent compiler warnings */
    ruleOCTAL_LITERALEx: ;

}
// $ANTLR end OCTAL_LITERAL

//   Comes from: 589:10: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HexDigit
 *
 * Looks to match the characters the constitute the token HexDigit
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHexDigit(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // PBJ.g:589:10: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
    // PBJ.g:589:12: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHexDigitEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHexDigitEx; /* Prevent compiler warnings */
    ruleHexDigitEx: ;

}
// $ANTLR end HexDigit

//   Comes from: 593:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )? | '.' ( '0' .. '9' )+ ( Exponent )? | ( '0' .. '9' )+ Exponent )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOATING_POINT_LITERAL
 *
 * Looks to match the characters the constitute the token FLOATING_POINT_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOATING_POINT_LITERAL(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLOATING_POINT_LITERAL;
       
    
    {
        //  PBJ.g:593:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )? | '.' ( '0' .. '9' )+ ( Exponent )? | ( '0' .. '9' )+ Exponent )
        
        ANTLR3_UINT32 alt13;

        alt13=3;

        alt13 = cdfa13.predict(ctx, RECOGNIZER, ISTREAM, &cdfa13);
        if  (HASEXCEPTION())
        {
            goto ruleFLOATING_POINT_LITERALEx;
        }

        switch (alt13) 
        {
    	case 1:
    	    // PBJ.g:593:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( Exponent )?
    	    {
    	        // PBJ.g:593:9: ( '0' .. '9' )+
    	        {
    	            int cnt7=0;

    	            for (;;)
    	            {
    	                int alt7=2;
    	        	{
    	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	        	    */
    	        	    int LA7_0 = LA(1);
    	        	    if ( (((LA7_0 >= '0') && (LA7_0 <= '9'))) ) 
    	        	    {
    	        	        alt7=1;
    	        	    }

    	        	}
    	        	switch (alt7) 
    	        	{
    	        	    case 1:
    	        	        // PBJ.g:593:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt7 >= 1 )
    	        		{
    	        		    goto loop7;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt7++;
    	            }
    	            loop7: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }


    	        // PBJ.g:593:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt8=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA8_0 = LA(1);
    	                if ( (((LA8_0 >= '0') && (LA8_0 <= '9'))) ) 
    	                {
    	                    alt8=1;
    	                }

    	            }
    	            switch (alt8) 
    	            {
    	        	case 1:
    	        	    // PBJ.g:593:26: '0' .. '9'
    	        	    {
    	        	        MATCHRANGE('0', '9'); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop8;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop8: ; /* Jump out to here if this rule does not match */


    	        // PBJ.g:593:37: ( Exponent )?
    	        {
    	            int alt9=2;
    	            {
    	                int LA9_0 = LA(1);
    	                if ( (LA9_0 == 'E' || LA9_0 == 'e') ) 
    	                {
    	                    alt9=1;
    	                }
    	            }
    	            switch (alt9) 
    	            {
    	        	case 1:
    	        	    // PBJ.g:593:37: Exponent
    	        	    {
    	        	        /* 593:37: Exponent */
    	        	        mExponent(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // PBJ.g:594:9: '.' ( '0' .. '9' )+ ( Exponent )?
    	    {
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }

    	        // PBJ.g:594:13: ( '0' .. '9' )+
    	        {
    	            int cnt10=0;

    	            for (;;)
    	            {
    	                int alt10=2;
    	        	{
    	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	        	    */
    	        	    int LA10_0 = LA(1);
    	        	    if ( (((LA10_0 >= '0') && (LA10_0 <= '9'))) ) 
    	        	    {
    	        	        alt10=1;
    	        	    }

    	        	}
    	        	switch (alt10) 
    	        	{
    	        	    case 1:
    	        	        // PBJ.g:594:14: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt10 >= 1 )
    	        		{
    	        		    goto loop10;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt10++;
    	            }
    	            loop10: ;	/* Jump to here if this rule does not match */
    	        }

    	        // PBJ.g:594:25: ( Exponent )?
    	        {
    	            int alt11=2;
    	            {
    	                int LA11_0 = LA(1);
    	                if ( (LA11_0 == 'E' || LA11_0 == 'e') ) 
    	                {
    	                    alt11=1;
    	                }
    	            }
    	            switch (alt11) 
    	            {
    	        	case 1:
    	        	    // PBJ.g:594:25: Exponent
    	        	    {
    	        	        /* 594:25: Exponent */
    	        	        mExponent(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 3:
    	    // PBJ.g:595:9: ( '0' .. '9' )+ Exponent
    	    {
    	        // PBJ.g:595:9: ( '0' .. '9' )+
    	        {
    	            int cnt12=0;

    	            for (;;)
    	            {
    	                int alt12=2;
    	        	{
    	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	        	    */
    	        	    int LA12_0 = LA(1);
    	        	    if ( (((LA12_0 >= '0') && (LA12_0 <= '9'))) ) 
    	        	    {
    	        	        alt12=1;
    	        	    }

    	        	}
    	        	switch (alt12) 
    	        	{
    	        	    case 1:
    	        	        // PBJ.g:595:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt12 >= 1 )
    	        		{
    	        		    goto loop12;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt12++;
    	            }
    	            loop12: ;	/* Jump to here if this rule does not match */
    	        }
    	        /* 595:9: ( '0' .. '9' )+ Exponent */
    	        mExponent(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }


    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATING_POINT_LITERALEx; /* Prevent compiler warnings */
    ruleFLOATING_POINT_LITERALEx: ;

}
// $ANTLR end FLOATING_POINT_LITERAL

//   Comes from: 599:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start Exponent
 *
 * Looks to match the characters the constitute the token Exponent
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mExponent(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // PBJ.g:599:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // PBJ.g:599:12: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleExponentEx;
        }


        // PBJ.g:599:22: ( '+' | '-' )?
        {
            int alt14=2;
            {
                int LA14_0 = LA(1);
                if ( (LA14_0 == '+' || LA14_0 == '-') ) 
                {
                    alt14=1;
                }
            }
            switch (alt14) 
            {
        	case 1:
        	    // PBJ.g:
        	    {
        	        if ( LA(1) == '+' || LA(1) == '-' )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleExponentEx;
        	        }


        	    }
        	    break;

            }
        }
        // PBJ.g:599:33: ( '0' .. '9' )+
        {
            int cnt15=0;

            for (;;)
            {
                int alt15=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA15_0 = LA(1);
        	    if ( (((LA15_0 >= '0') && (LA15_0 <= '9'))) ) 
        	    {
        	        alt15=1;
        	    }

        	}
        	switch (alt15) 
        	{
        	    case 1:
        	        // PBJ.g:599:34: '0' .. '9'
        	        {
        	            MATCHRANGE('0', '9'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleExponentEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt15 >= 1 )
        		{
        		    goto loop15;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleExponentEx;
        	}
        	cnt15++;
            }
            loop15: ;	/* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleExponentEx; /* Prevent compiler warnings */
    ruleExponentEx: ;

}
// $ANTLR end Exponent

//   Comes from: 604:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | OctalEscape )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EscapeSequence
 *
 * Looks to match the characters the constitute the token EscapeSequence
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEscapeSequence(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  PBJ.g:604:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | OctalEscape )
        
        ANTLR3_UINT32 alt16;

        alt16=2;


        {
            int LA16_0 = LA(1);
            if ( (LA16_0 == '\\') ) 
            {

                {
                    int LA16_1 = LA(2);
                    if ( (LA16_1 == '"' || LA16_1 == '\'' || LA16_1 == '\\' || LA16_1 == 'b' || LA16_1 == 'f' || LA16_1 == 'n' || LA16_1 == 'r' || LA16_1 == 't') ) 
                    {
                        alt16=1;
                    }
                    else if ( (((LA16_1 >= '0') && (LA16_1 <= '7'))) ) 
                    {
                        alt16=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 16;
                        EXCEPTION->state        = 1;


                        goto ruleEscapeSequenceEx;
                    }
                }
            }
            else 
            {
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto ruleEscapeSequenceEx;
            }
        }
        switch (alt16) 
        {
    	case 1:
    	    // PBJ.g:604:9: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleEscapeSequenceEx;
    	        }

    	        if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == '\\' || LA(1) == 'b' || LA(1) == 'f' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' )
    	        {
    	            CONSUME();

    	        }
    	        else 
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleEscapeSequenceEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PBJ.g:605:9: OctalEscape
    	    {
    	        /* 605:9: OctalEscape */
    	        mOctalEscape(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleEscapeSequenceEx;
    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleEscapeSequenceEx; /* Prevent compiler warnings */
    ruleEscapeSequenceEx: ;

}
// $ANTLR end EscapeSequence

//   Comes from: 610:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OctalEscape
 *
 * Looks to match the characters the constitute the token OctalEscape
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOctalEscape(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  PBJ.g:610:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
        
        ANTLR3_UINT32 alt17;

        alt17=3;


        {
            int LA17_0 = LA(1);
            if ( (LA17_0 == '\\') ) 
            {

                {
                    int LA17_1 = LA(2);
                    if ( (((LA17_1 >= '0') && (LA17_1 <= '3'))) ) 
                    {

                        {
                            int LA17_2 = LA(3);
                            if ( (((LA17_2 >= '0') && (LA17_2 <= '7'))) ) 
                            {

                                {
                                    int LA17_5 = LA(4);
                                    if ( (((LA17_5 >= '0') && (LA17_5 <= '7'))) ) 
                                    {
                                        alt17=1;
                                    }
                                    else 
                                    {
                                        alt17=2;    }
                                }
                            }
                            else 
                            {
                                alt17=3;    }
                        }
                    }
                    else if ( (((LA17_1 >= '4') && (LA17_1 <= '7'))) ) 
                    {

                        {
                            int LA17_3 = LA(3);
                            if ( (((LA17_3 >= '0') && (LA17_3 <= '7'))) ) 
                            {
                                alt17=2;
                            }
                            else 
                            {
                                alt17=3;    }
                        }
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 17;
                        EXCEPTION->state        = 1;


                        goto ruleOctalEscapeEx;
                    }
                }
            }
            else 
            {
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto ruleOctalEscapeEx;
            }
        }
        switch (alt17) 
        {
    	case 1:
    	    // PBJ.g:610:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOctalEscapeEx;
    	        }

    	        // PBJ.g:610:14: ( '0' .. '3' )
    	        // PBJ.g:610:15: '0' .. '3'
    	        {
    	            MATCHRANGE('0', '3'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOctalEscapeEx;
    	            }


    	        }

    	        // PBJ.g:610:25: ( '0' .. '7' )
    	        // PBJ.g:610:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOctalEscapeEx;
    	            }


    	        }

    	        // PBJ.g:610:36: ( '0' .. '7' )
    	        // PBJ.g:610:37: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOctalEscapeEx;
    	            }


    	        }


    	    }
    	    break;
    	case 2:
    	    // PBJ.g:611:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOctalEscapeEx;
    	        }

    	        // PBJ.g:611:14: ( '0' .. '7' )
    	        // PBJ.g:611:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOctalEscapeEx;
    	            }


    	        }

    	        // PBJ.g:611:25: ( '0' .. '7' )
    	        // PBJ.g:611:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOctalEscapeEx;
    	            }


    	        }


    	    }
    	    break;
    	case 3:
    	    // PBJ.g:612:9: '\\\\' ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOctalEscapeEx;
    	        }

    	        // PBJ.g:612:14: ( '0' .. '7' )
    	        // PBJ.g:612:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOctalEscapeEx;
    	            }


    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleOctalEscapeEx; /* Prevent compiler warnings */
    ruleOctalEscapeEx: ;

}
// $ANTLR end OctalEscape

//   Comes from: 617:5: ( '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UnicodeEscape
 *
 * Looks to match the characters the constitute the token UnicodeEscape
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUnicodeEscape(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // PBJ.g:617:5: ( '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit )
    // PBJ.g:617:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit
    {
        MATCHC('\\'); 
        if  (HASEXCEPTION())
        {
            goto ruleUnicodeEscapeEx;
        }

        MATCHC('u'); 
        if  (HASEXCEPTION())
        {
            goto ruleUnicodeEscapeEx;
        }

        /* 617:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit */
        mHexDigit(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUnicodeEscapeEx;
        }

        /* 617:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit */
        mHexDigit(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUnicodeEscapeEx;
        }

        /* 617:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit */
        mHexDigit(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUnicodeEscapeEx;
        }

        /* 617:9: '\\\\' 'u' HexDigit HexDigit HexDigit HexDigit */
        mHexDigit(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUnicodeEscapeEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleUnicodeEscapeEx; /* Prevent compiler warnings */
    ruleUnicodeEscapeEx: ;

}
// $ANTLR end UnicodeEscape

//   Comes from: 621:12: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IDENTIFIER
 *
 * Looks to match the characters the constitute the token IDENTIFIER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIDENTIFIER(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IDENTIFIER;
       
    
    // PBJ.g:621:12: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
    // PBJ.g:621:14: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleIDENTIFIEREx;
        }


        // PBJ.g:621:41: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*

        for (;;)
        {
            int alt18=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA18_0 = LA(1);
                if ( (((LA18_0 >= '0') && (LA18_0 <= '9')) || ((LA18_0 >= 'A') && (LA18_0 <= 'Z')) || LA18_0 == '_' || ((LA18_0 >= 'a') && (LA18_0 <= 'z'))) ) 
                {
                    alt18=1;
                }

            }
            switch (alt18) 
            {
        	case 1:
        	    // PBJ.g:
        	    {
        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleIDENTIFIEREx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop18;	/* break out of the loop */
        	    break;
            }
        }
        loop18: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIDENTIFIEREx; /* Prevent compiler warnings */
    ruleIDENTIFIEREx: ;

}
// $ANTLR end IDENTIFIER

//   Comes from: 624:21: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '.' | '0' .. '9' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUALIFIEDIDENTIFIER
 *
 * Looks to match the characters the constitute the token QUALIFIEDIDENTIFIER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQUALIFIEDIDENTIFIER(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = QUALIFIEDIDENTIFIER;
       
    
    // PBJ.g:624:21: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '.' | '0' .. '9' )* )
    // PBJ.g:624:23: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '.' | '0' .. '9' )*
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleQUALIFIEDIDENTIFIEREx;
        }


        // PBJ.g:624:50: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '.' | '0' .. '9' )*

        for (;;)
        {
            int alt19=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA19_0 = LA(1);
                if ( (LA19_0 == '.' || ((LA19_0 >= '0') && (LA19_0 <= '9')) || ((LA19_0 >= 'A') && (LA19_0 <= 'Z')) || LA19_0 == '_' || ((LA19_0 >= 'a') && (LA19_0 <= 'z'))) ) 
                {
                    alt19=1;
                }

            }
            switch (alt19) 
            {
        	case 1:
        	    // PBJ.g:
        	    {
        	        if ( LA(1) == '.' || ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleQUALIFIEDIDENTIFIEREx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop19;	/* break out of the loop */
        	    break;
            }
        }
        loop19: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleQUALIFIEDIDENTIFIEREx; /* Prevent compiler warnings */
    ruleQUALIFIEDIDENTIFIEREx: ;

}
// $ANTLR end QUALIFIEDIDENTIFIER

//   Comes from: 626:9: ( '//' ( . )* '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COMMENT;
       
    
    {
        //  PBJ.g:626:9: ( '//' ( . )* '\\n' | '/*' ( options {greedy=false; } : . )* '*/' )
        
        ANTLR3_UINT32 alt22;

        alt22=2;


        {
            int LA22_0 = LA(1);
            if ( (LA22_0 == '/') ) 
            {

                {
                    int LA22_1 = LA(2);
                    if ( (LA22_1 == '/') ) 
                    {
                        alt22=1;
                    }
                    else if ( (LA22_1 == '*') ) 
                    {
                        alt22=2;
                    }
                    else 
                    {
                    
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 22;
                        EXCEPTION->state        = 1;


                        goto ruleCOMMENTEx;
                    }
                }
            }
            else 
            {
            
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto ruleCOMMENTEx;
            }
        }
        switch (alt22) 
        {
    	case 1:
    	    // PBJ.g:626:11: '//' ( . )* '\\n'
    	    {
    	        MATCHS(lit_62); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleCOMMENTEx;
    	        }



    	        // PBJ.g:626:16: ( . )*

    	        for (;;)
    	        {
    	            int alt20=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA20_0 = LA(1);
    	                if ( (LA20_0 == '\n') ) 
    	                {
    	                    alt20=2;
    	                }
    	                else if ( (((LA20_0 >= 0x0000) && (LA20_0 <= '\t')) || ((LA20_0 >= 0x000B) && (LA20_0 <= 0xFFFF))) ) 
    	                {
    	                    alt20=1;
    	                }

    	            }
    	            switch (alt20) 
    	            {
    	        	case 1:
    	        	    // PBJ.g:626:16: .
    	        	    {
    	        	        MATCHANY(); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop20;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop20: ; /* Jump out to here if this rule does not match */

    	        MATCHC('\n'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleCOMMENTEx;
    	        }

    	        {
    	            LEXSTATE->channel=HIDDEN;
    	        }

    	    }
    	    break;
    	case 2:
    	    // PBJ.g:627:11: '/*' ( options {greedy=false; } : . )* '*/'
    	    {
    	        MATCHS(lit_63); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleCOMMENTEx;
    	        }



    	        // PBJ.g:627:16: ( options {greedy=false; } : . )*

    	        for (;;)
    	        {
    	            int alt21=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA21_0 = LA(1);
    	                if ( (LA21_0 == '*') ) 
    	                {
    	                    {
    	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                        */
    	                        int LA21_1 = LA(2);
    	                        if ( (LA21_1 == '/') ) 
    	                        {
    	                            alt21=2;
    	                        }
    	                        else if ( (((LA21_1 >= 0x0000) && (LA21_1 <= '.')) || ((LA21_1 >= '0') && (LA21_1 <= 0xFFFF))) ) 
    	                        {
    	                            alt21=1;
    	                        }

    	                    }
    	                }
    	                else if ( (((LA21_0 >= 0x0000) && (LA21_0 <= ')')) || ((LA21_0 >= '+') && (LA21_0 <= 0xFFFF))) ) 
    	                {
    	                    alt21=1;
    	                }

    	            }
    	            switch (alt21) 
    	            {
    	        	case 1:
    	        	    // PBJ.g:627:44: .
    	        	    {
    	        	        MATCHANY(); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop21;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop21: ; /* Jump out to here if this rule does not match */

    	        MATCHS(lit_64); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleCOMMENTEx;
    	        }


    	        {
    	            LEXSTATE->channel=HIDDEN;
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 630:10: ( ( ' ' | '\\t' | '\\n' | '\\r' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pPBJLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WS;
       
    
    // PBJ.g:630:10: ( ( ' ' | '\\t' | '\\n' | '\\r' )+ )
    // PBJ.g:630:12: ( ' ' | '\\t' | '\\n' | '\\r' )+
    {
        // PBJ.g:630:12: ( ' ' | '\\t' | '\\n' | '\\r' )+
        {
            int cnt23=0;

            for (;;)
            {
                int alt23=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA23_0 = LA(1);
        	    if ( (((LA23_0 >= '\t') && (LA23_0 <= '\n')) || LA23_0 == '\r' || LA23_0 == ' ') ) 
        	    {
        	        alt23=1;
        	    }

        	}
        	switch (alt23) 
        	{
        	    case 1:
        	        // PBJ.g:
        	        {
        	            if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || LA(1) == '\r' || LA(1) == ' ' )
        	            {
        	                CONSUME();

        	            }
        	            else 
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleWSEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt23 >= 1 )
        		{
        		    goto loop23;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleWSEx;
        	}
        	cnt23++;
            }
            loop23: ;	/* Jump to here if this rule does not match */
        }
        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pPBJLexer ctx)
{
    {
        //  PBJ.g:1:8: ( PACKAGELITERAL | IMPORTLITERAL | DOT | MESSAGE | EXTEND | EXTENSIONS | RESERVE | TO | ENUM | FLAGS8 | FLAGS16 | FLAGS32 | FLAGS64 | REQUIRED | PBJOPTIONAL | REPEATED | DEFAULT | EQUALS | BLOCK_OPEN | BLOCK_CLOSE | ITEM_TERMINATOR | UINT8 | INT8 | SINT8 | FIXED8 | SFIXED8 | UINT16 | INT16 | SINT16 | FIXED16 | SFIXED16 | UINT32 | INT32 | SINT32 | FIXED32 | SFIXED32 | UINT64 | INT64 | SINT64 | FIXED64 | SFIXED64 | FLOAT | DOUBLE | BOOL | BYTES | STRING | UUID | SHA256 | ANGLE | SOLIDANGLE | TIME | DURATION | NORMAL | VECTOR2F | VECTOR2D | VECTOR3F | VECTOR3D | VECTOR4F | VECTOR4D | QUATERNION | BOUNDINGSPHERE3F | BOUNDINGSPHERE3D | BOUNDINGBOX3F3F | BOUNDINGBOX3D3F | SQBRACKET_OPEN | SQBRACKET_CLOSE | STRING_LITERAL | BOOL_LITERAL | HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOATING_POINT_LITERAL | IDENTIFIER | QUALIFIEDIDENTIFIER | COMMENT | WS )
        
        ANTLR3_UINT32 alt24;

        alt24=76;

        alt24 = cdfa24.predict(ctx, RECOGNIZER, ISTREAM, &cdfa24);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }

        switch (alt24) 
        {
    	case 1:
    	    // PBJ.g:1:10: PACKAGELITERAL
    	    {
    	        /* 1:10: PACKAGELITERAL */
    	        mPACKAGELITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PBJ.g:1:25: IMPORTLITERAL
    	    {
    	        /* 1:25: IMPORTLITERAL */
    	        mIMPORTLITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // PBJ.g:1:39: DOT
    	    {
    	        /* 1:39: DOT */
    	        mDOT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // PBJ.g:1:43: MESSAGE
    	    {
    	        /* 1:43: MESSAGE */
    	        mMESSAGE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 5:
    	    // PBJ.g:1:51: EXTEND
    	    {
    	        /* 1:51: EXTEND */
    	        mEXTEND(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 6:
    	    // PBJ.g:1:58: EXTENSIONS
    	    {
    	        /* 1:58: EXTENSIONS */
    	        mEXTENSIONS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 7:
    	    // PBJ.g:1:69: RESERVE
    	    {
    	        /* 1:69: RESERVE */
    	        mRESERVE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 8:
    	    // PBJ.g:1:77: TO
    	    {
    	        /* 1:77: TO */
    	        mTO(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 9:
    	    // PBJ.g:1:80: ENUM
    	    {
    	        /* 1:80: ENUM */
    	        mENUM(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 10:
    	    // PBJ.g:1:85: FLAGS8
    	    {
    	        /* 1:85: FLAGS8 */
    	        mFLAGS8(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 11:
    	    // PBJ.g:1:92: FLAGS16
    	    {
    	        /* 1:92: FLAGS16 */
    	        mFLAGS16(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 12:
    	    // PBJ.g:1:100: FLAGS32
    	    {
    	        /* 1:100: FLAGS32 */
    	        mFLAGS32(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 13:
    	    // PBJ.g:1:108: FLAGS64
    	    {
    	        /* 1:108: FLAGS64 */
    	        mFLAGS64(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 14:
    	    // PBJ.g:1:116: REQUIRED
    	    {
    	        /* 1:116: REQUIRED */
    	        mREQUIRED(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 15:
    	    // PBJ.g:1:125: PBJOPTIONAL
    	    {
    	        /* 1:125: PBJOPTIONAL */
    	        mPBJOPTIONAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 16:
    	    // PBJ.g:1:137: REPEATED
    	    {
    	        /* 1:137: REPEATED */
    	        mREPEATED(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 17:
    	    // PBJ.g:1:146: DEFAULT
    	    {
    	        /* 1:146: DEFAULT */
    	        mDEFAULT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 18:
    	    // PBJ.g:1:154: EQUALS
    	    {
    	        /* 1:154: EQUALS */
    	        mEQUALS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 19:
    	    // PBJ.g:1:161: BLOCK_OPEN
    	    {
    	        /* 1:161: BLOCK_OPEN */
    	        mBLOCK_OPEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 20:
    	    // PBJ.g:1:172: BLOCK_CLOSE
    	    {
    	        /* 1:172: BLOCK_CLOSE */
    	        mBLOCK_CLOSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 21:
    	    // PBJ.g:1:184: ITEM_TERMINATOR
    	    {
    	        /* 1:184: ITEM_TERMINATOR */
    	        mITEM_TERMINATOR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 22:
    	    // PBJ.g:1:200: UINT8
    	    {
    	        /* 1:200: UINT8 */
    	        mUINT8(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 23:
    	    // PBJ.g:1:206: INT8
    	    {
    	        /* 1:206: INT8 */
    	        mINT8(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 24:
    	    // PBJ.g:1:211: SINT8
    	    {
    	        /* 1:211: SINT8 */
    	        mSINT8(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 25:
    	    // PBJ.g:1:217: FIXED8
    	    {
    	        /* 1:217: FIXED8 */
    	        mFIXED8(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 26:
    	    // PBJ.g:1:224: SFIXED8
    	    {
    	        /* 1:224: SFIXED8 */
    	        mSFIXED8(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 27:
    	    // PBJ.g:1:232: UINT16
    	    {
    	        /* 1:232: UINT16 */
    	        mUINT16(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 28:
    	    // PBJ.g:1:239: INT16
    	    {
    	        /* 1:239: INT16 */
    	        mINT16(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 29:
    	    // PBJ.g:1:245: SINT16
    	    {
    	        /* 1:245: SINT16 */
    	        mSINT16(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 30:
    	    // PBJ.g:1:252: FIXED16
    	    {
    	        /* 1:252: FIXED16 */
    	        mFIXED16(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 31:
    	    // PBJ.g:1:260: SFIXED16
    	    {
    	        /* 1:260: SFIXED16 */
    	        mSFIXED16(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 32:
    	    // PBJ.g:1:269: UINT32
    	    {
    	        /* 1:269: UINT32 */
    	        mUINT32(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 33:
    	    // PBJ.g:1:276: INT32
    	    {
    	        /* 1:276: INT32 */
    	        mINT32(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 34:
    	    // PBJ.g:1:282: SINT32
    	    {
    	        /* 1:282: SINT32 */
    	        mSINT32(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 35:
    	    // PBJ.g:1:289: FIXED32
    	    {
    	        /* 1:289: FIXED32 */
    	        mFIXED32(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 36:
    	    // PBJ.g:1:297: SFIXED32
    	    {
    	        /* 1:297: SFIXED32 */
    	        mSFIXED32(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 37:
    	    // PBJ.g:1:306: UINT64
    	    {
    	        /* 1:306: UINT64 */
    	        mUINT64(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 38:
    	    // PBJ.g:1:313: INT64
    	    {
    	        /* 1:313: INT64 */
    	        mINT64(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 39:
    	    // PBJ.g:1:319: SINT64
    	    {
    	        /* 1:319: SINT64 */
    	        mSINT64(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 40:
    	    // PBJ.g:1:326: FIXED64
    	    {
    	        /* 1:326: FIXED64 */
    	        mFIXED64(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 41:
    	    // PBJ.g:1:334: SFIXED64
    	    {
    	        /* 1:334: SFIXED64 */
    	        mSFIXED64(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 42:
    	    // PBJ.g:1:343: FLOAT
    	    {
    	        /* 1:343: FLOAT */
    	        mFLOAT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 43:
    	    // PBJ.g:1:349: DOUBLE
    	    {
    	        /* 1:349: DOUBLE */
    	        mDOUBLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 44:
    	    // PBJ.g:1:356: BOOL
    	    {
    	        /* 1:356: BOOL */
    	        mBOOL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 45:
    	    // PBJ.g:1:361: BYTES
    	    {
    	        /* 1:361: BYTES */
    	        mBYTES(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 46:
    	    // PBJ.g:1:367: STRING
    	    {
    	        /* 1:367: STRING */
    	        mSTRING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 47:
    	    // PBJ.g:1:374: UUID
    	    {
    	        /* 1:374: UUID */
    	        mUUID(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 48:
    	    // PBJ.g:1:379: SHA256
    	    {
    	        /* 1:379: SHA256 */
    	        mSHA256(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 49:
    	    // PBJ.g:1:386: ANGLE
    	    {
    	        /* 1:386: ANGLE */
    	        mANGLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 50:
    	    // PBJ.g:1:392: SOLIDANGLE
    	    {
    	        /* 1:392: SOLIDANGLE */
    	        mSOLIDANGLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 51:
    	    // PBJ.g:1:403: TIME
    	    {
    	        /* 1:403: TIME */
    	        mTIME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 52:
    	    // PBJ.g:1:408: DURATION
    	    {
    	        /* 1:408: DURATION */
    	        mDURATION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 53:
    	    // PBJ.g:1:417: NORMAL
    	    {
    	        /* 1:417: NORMAL */
    	        mNORMAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 54:
    	    // PBJ.g:1:424: VECTOR2F
    	    {
    	        /* 1:424: VECTOR2F */
    	        mVECTOR2F(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 55:
    	    // PBJ.g:1:433: VECTOR2D
    	    {
    	        /* 1:433: VECTOR2D */
    	        mVECTOR2D(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 56:
    	    // PBJ.g:1:442: VECTOR3F
    	    {
    	        /* 1:442: VECTOR3F */
    	        mVECTOR3F(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 57:
    	    // PBJ.g:1:451: VECTOR3D
    	    {
    	        /* 1:451: VECTOR3D */
    	        mVECTOR3D(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 58:
    	    // PBJ.g:1:460: VECTOR4F
    	    {
    	        /* 1:460: VECTOR4F */
    	        mVECTOR4F(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 59:
    	    // PBJ.g:1:469: VECTOR4D
    	    {
    	        /* 1:469: VECTOR4D */
    	        mVECTOR4D(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 60:
    	    // PBJ.g:1:478: QUATERNION
    	    {
    	        /* 1:478: QUATERNION */
    	        mQUATERNION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 61:
    	    // PBJ.g:1:489: BOUNDINGSPHERE3F
    	    {
    	        /* 1:489: BOUNDINGSPHERE3F */
    	        mBOUNDINGSPHERE3F(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 62:
    	    // PBJ.g:1:506: BOUNDINGSPHERE3D
    	    {
    	        /* 1:506: BOUNDINGSPHERE3D */
    	        mBOUNDINGSPHERE3D(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 63:
    	    // PBJ.g:1:523: BOUNDINGBOX3F3F
    	    {
    	        /* 1:523: BOUNDINGBOX3F3F */
    	        mBOUNDINGBOX3F3F(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 64:
    	    // PBJ.g:1:539: BOUNDINGBOX3D3F
    	    {
    	        /* 1:539: BOUNDINGBOX3D3F */
    	        mBOUNDINGBOX3D3F(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 65:
    	    // PBJ.g:1:555: SQBRACKET_OPEN
    	    {
    	        /* 1:555: SQBRACKET_OPEN */
    	        mSQBRACKET_OPEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 66:
    	    // PBJ.g:1:570: SQBRACKET_CLOSE
    	    {
    	        /* 1:570: SQBRACKET_CLOSE */
    	        mSQBRACKET_CLOSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 67:
    	    // PBJ.g:1:586: STRING_LITERAL
    	    {
    	        /* 1:586: STRING_LITERAL */
    	        mSTRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 68:
    	    // PBJ.g:1:601: BOOL_LITERAL
    	    {
    	        /* 1:601: BOOL_LITERAL */
    	        mBOOL_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 69:
    	    // PBJ.g:1:614: HEX_LITERAL
    	    {
    	        /* 1:614: HEX_LITERAL */
    	        mHEX_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 70:
    	    // PBJ.g:1:626: DECIMAL_LITERAL
    	    {
    	        /* 1:626: DECIMAL_LITERAL */
    	        mDECIMAL_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 71:
    	    // PBJ.g:1:642: OCTAL_LITERAL
    	    {
    	        /* 1:642: OCTAL_LITERAL */
    	        mOCTAL_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 72:
    	    // PBJ.g:1:656: FLOATING_POINT_LITERAL
    	    {
    	        /* 1:656: FLOATING_POINT_LITERAL */
    	        mFLOATING_POINT_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 73:
    	    // PBJ.g:1:679: IDENTIFIER
    	    {
    	        /* 1:679: IDENTIFIER */
    	        mIDENTIFIER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 74:
    	    // PBJ.g:1:690: QUALIFIEDIDENTIFIER
    	    {
    	        /* 1:690: QUALIFIEDIDENTIFIER */
    	        mQUALIFIEDIDENTIFIER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 75:
    	    // PBJ.g:1:710: COMMENT
    	    {
    	        /* 1:710: COMMENT */
    	        mCOMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 76:
    	    // PBJ.g:1:718: WS
    	    {
    	        /* 1:718: WS */
    	        mWS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
